<!DOCTYPE html>
<html>
<head>
  <style>
    html, body { 
      background: none; 
      margin: 0; 
      padding: 0; 
      height: 100%; 
      width: 100%;
      overflow: hidden;
    }
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <script src="https://unpkg.com/@rive-app/webgl2"></script>
  <canvas id="canvas"></canvas>
  <script src="https://libs.singular.live/singularwidget/1.0.3/singularwidget.js"></script>
  <script>
    let riveProps = {};
    let r = null;
    
    // Function to resize canvas to match window size
    function resizeCanvas() {
      const canvas = document.getElementById("canvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      if (r) {
        r.resizeDrawingSurfaceToCanvas();
      }
    }

    // Listen for window resize events
    window.addEventListener('resize', resizeCanvas);

    // Get all properties from a view model 
    function collectProperties(vmi, viewModel, props, pathPrefix = "") {
      const properties = viewModel.properties;
      if (!properties || !properties.length) return;

      for (const property of properties) {
        if (!property || !property.name) continue;
        
        // Skip nested view model properties - they're just references not actual data
        if (property.type === "viewModel") {
          console.log(`Skipping nested VM reference: ${property.name}`);
          continue;
        }
        
        // Build the path for accessing this property
        const propertyPath = pathPrefix ? `${pathPrefix}/${property.name}` : property.name;
        
        // Create accessor for this property
        let accessor = null;
        try {
          switch(property.type) {
            case "string":   accessor = vmi.string(propertyPath); break;
            case "number":   accessor = vmi.number(propertyPath); break;
            case "boolean":  accessor = vmi.boolean(propertyPath); break;
            case "trigger":  accessor = vmi.trigger(propertyPath); break;
            case "color":    accessor = vmi.color(propertyPath); break;
            case "enum":     accessor = vmi.enum(propertyPath); break;
          }
        } catch (err) {
          console.error(`‚ùå Error accessing '${propertyPath}':`, err.message);
        }

        if (accessor) {
          // Use path with / for Rive access, but store with _ for SingularLive ID compatibility
          const propKey = propertyPath.replace(/\//g, '_');
          props[propKey] = { 
            type: property.type, 
            accessor,
            path: propertyPath  // Keep original path for Rive
          };
          console.log(`‚úÖ ${propKey} (${property.type}) [rive path: ${propertyPath}]`);
        }
      }
    }

    // Collect all properties from all view models
    function GetAllViewModelProperties(rive) {
      const props = {};
      
      console.log(`Found ${rive.viewModelCount} view model(s)`);
      
      const vmi = rive.viewModelInstance;
      
      const defaultVM = rive.defaultViewModel();
      if (!defaultVM) {
        console.error("‚ùå No default view model");
        return props;
      }
      console.log(`Root VM: ${defaultVM.name || 'Unnamed'}`);
      
      // First: Collect properties from root view model
      collectProperties(vmi, defaultVM, props, "");
      
      // Second: Find nested VM properties and collect from ALL nested VMs
      const rootProperties = defaultVM.properties;
      const processedVMs = new Set([defaultVM]); 
      
      for (const prop of rootProperties) {
        if (prop && prop.type === "viewModel" && prop.name) {
          console.log(`\n Found nested VM property: "${prop.name}"`);
          
          // Try to match this property to a specific view model
          // The property name might contain the VM name (e.g., "property of View Model 2")
          let matchedVM = null;
          
          for (let i = 0; i < rive.viewModelCount; i++) {
            const vm = rive.viewModelByIndex(i);
            if (!vm || processedVMs.has(vm)) continue;
            
            // Check if the property name contains this VM's name
            if (vm.name && prop.name.includes(vm.name)) {
              matchedVM = vm;
              break;
            }
          }
          
          // If no match by name, just take the next unprocessed VM
          if (!matchedVM) {
            for (let i = 0; i < rive.viewModelCount; i++) {
              const vm = rive.viewModelByIndex(i);
              if (vm && !processedVMs.has(vm)) {
                matchedVM = vm;
                break;
              }
            }
          }
          
          if (matchedVM) {
            console.log(`Nested VM: ${matchedVM.name || 'Unnamed'}`);
            processedVMs.add(matchedVM);
            // collect nested VM properties with updated path prefix
            collectProperties(vmi, matchedVM, props, prop.name);
          }
        }
      }
      
      console.log(`\n‚úÖ Total properties collected: ${Object.keys(props).length}`);
      return props;
    }

    function listAllArtboards(riveInstance) {
      console.log("\nüìã Available Artboards:");
      console.log("=" + "=".repeat(60));
      
      try {
        const file = riveInstance.file;
        if (!file) {
          console.log("‚ö†Ô∏è Cannot access Rive file object");
          return;
        }
        
        const artboardCount = file.artboardCount();  // Call it as a function
        console.log(`Total artboards: ${artboardCount}\n`);
        
        for (let i = 0; i < artboardCount; i++) {
          const artboard = file.artboardByIndex(i);  // This might also need ()
          if (artboard) {
            const artboardName = typeof artboard.name === 'function' ? artboard.name() : artboard.name;
            const isDefault = i === 0 ? " (default)" : "";
            console.log(`  ${i + 1}. "${artboardName}"${isDefault}`);
          }
        }
        
        console.log("=" + "=".repeat(60) + "\n");
      } catch (err) {
        console.error("‚ùå Error listing artboards:", err);
      }
    }
    
    // Initialize Rive
    let ARTBOARD_NAME = ""; 
    const STATE_MACHINE_NAME = "State Machine 1"; 
    let LAYOUT_FIT = "contain";
    
    const riveConfig = {
      src: "test_file.riv",
      canvas: document.getElementById("canvas"),
      autoplay: true,
      autoBind: true,
      stateMachines: STATE_MACHINE_NAME,
      onLoad: () => {
        console.log("Rive loaded\n");
        listAllArtboards(r);
        console.log(`‚úÖ Active artboard: ${r.activeArtboard?.name || 'default'}`);
        
        resizeCanvas();
        
        if (r.viewModelCount === 0) {
          console.error("No view models found in this artboard");
          return;
        }

        riveProps = GetAllViewModelProperties(r);
        
        if (Object.keys(riveProps).length == 0) {
          console.warn("No properties found. Make sure the view model has properties defined.");
        }
        
        generateUIModel();
        
        // Apply pending initial values if they exist
        if (window.pendingInitialValues) {
          console.log("üé¨ Applying pending initial values from init...");
          const initialValues = window.pendingInitialValues;
          window.pendingInitialValues = null; // Clear before processing to avoid loops
          onSingularValue(initialValues);
        }
      },
      onLoadError: (err) => {
        console.error("‚ùå Rive load error:", err);
        if (err.data && err.data.includes("artboard")) {
          console.log("üí° Artboard issue - try one of these fixes:");
          console.log("   1. Leave ARTBOARD_NAME empty to use default artboard");
          console.log("   2. Check artboard name spelling (case-sensitive)");
          console.log("   3. Make sure the artboard exists in your .riv file");
        }
      },
    };
    
    // Only add artboard property if a specific name is provided
    if (ARTBOARD_NAME) {
      riveConfig.artboard = ARTBOARD_NAME;
      console.log(`üéØ Targeting artboard: "${ARTBOARD_NAME}"`);
    } else {
      console.log("üéØ Using default artboard");
    }
    
    r = new rive.Rive(riveConfig);

    // Generate JSON for Widget Manager
    function generateUIModel() {
      const fields = [];
      const groupedProperties = {};
      
      // Get available artboards dynamically
      const availableArtboards = [];
      try {
        const file = r.file;
        if (file) {
          const artboardCount = file.artboardCount();
          for (let i = 0; i < artboardCount; i++) {
            const artboard = file.artboardByIndex(i);
            if (artboard) {
              const artboardName = typeof artboard.name === 'function' ? artboard.name() : artboard.name;
              availableArtboards.push(artboardName);
            }
          }
        }
      } catch (err) {
        console.error("Could not fetch artboards for UI:", err);
      }
      
      // Add Rive configuration fields (these don't come from view models)
      const riveConfigFields = [
        {
          id: "rive_file_url",
          type: "text",
          title: "Rive File URL",
          defaultValue: "test_file.riv"
        },
        {
          id: "rive_artboard",
          type: "selection",
          title: "Artboard",
          defaultValue: "0",
          selections: availableArtboards.map((name, index) => ({
            id: index.toString(),
            title: name
          }))
        },
        {
          id: "rive_layout",
          type: "selection",
          title: "Layout",
          defaultValue: "0",
          selections: [
            { id: "0", title: "Contain" },
            { id: "1", title: "Cover" },
            { id: "2", title: "Fill" },
            { id: "3", title: "Fit Width" },
            { id: "4", title: "Fit Height" },
            { id: "5", title: "Scale Down" },
            { id: "6", title: "Layout" },
            { id: "7", title: "None" }
          ]
        }
      ];
      
      // Add config fields to main fields array
      fields.push(...riveConfigFields);
      
      // Track config field IDs for grouping (excluding removed button)
      const riveConfigIds = riveConfigFields.map(f => f.id).filter(id => id !== "rive_apply_settings");
      
      for (const [name, prop] of Object.entries(riveProps)) {
        // example "property_of_View_Model_3_Text" -> "Text"
        const displayName = name.includes('_') ? name.split('_').pop() : name;
        
        // Determine which view model this property belongs to
        let viewModelName = "Root View Model";
        if (name.includes('_')) {
          const parts = name.split('_');
          parts.pop(); 
          viewModelName = parts.join(' ');
          viewModelName = viewModelName.replace(/^property of /i, '');
        }
        
        let fieldType = prop.type;
        let defaultValue = "";
        
        // Map Rive types to SingularLive field types
        if (prop.type === "trigger") {
          fieldType = "button";
        } else if (prop.type === "string") {
          fieldType = "text";
          defaultValue = prop.accessor.value || "";
        } else if (prop.type === "number") {
          defaultValue = prop.accessor.value || 0;
        } else if (prop.type === "boolean") {
          defaultValue = prop.accessor.value || false;
        } else if (prop.type === "color") {
          const colorValue = prop.accessor.value;
          defaultValue = {
            r: (colorValue >> 16) & 0xFF,
            g: (colorValue >> 8) & 0xFF,
            b: colorValue & 0xFF,
            a: ((colorValue >> 24) & 0xFF) / 255
          };
        }
        
        const field = {
          id: name,
          type: fieldType,
          title: displayName.charAt(0).toUpperCase() + displayName.slice(1),
          defaultValue: defaultValue
        };
        
        fields.push(field);
        
        // Group by view model
        if (!groupedProperties[viewModelName]) {
          groupedProperties[viewModelName] = [];
        }
        groupedProperties[viewModelName].push(name);
      }

      // Create groups for each view model
      const groups = [];
      
      // Add Rive Configuration group FIRST
      groups.push({
        id: "rive_configuration_group",
        title: "Rive Configuration",
        width: "double",
        toolTip: "Configure Rive file source, artboard, and layout",
        childIds: riveConfigIds
      });
      
      // Add view model groups
      for (const [vmName, childIds] of Object.entries(groupedProperties)) {
        groups.push({
          id: vmName.replace(/\s+/g, '_').toLowerCase() + "_group",
          title: vmName,
          width: "double",
          toolTip: `Properties from ${vmName}`,
          childIds: childIds
        });
      }

      const model = { 
        model: { 
          fields, 
          groups
        }
      };

      console.log("\n COPY TO WIDGET MANAGER:");
      console.log("=".repeat(60));
      console.log(JSON.stringify(model, null, 2));
      console.log("=".repeat(60));
    }

    // SingularLive Widget Integration
    SingularWidget.init({
      onInit: onSingularInit,
      onValue: onSingularValue,
      onButtonClicked: onSingularButtonClicked,
      onEditComp: onSingularEditComp,
    });

    function onSingularInit(json) {
      console.log("SingularWidget initialized with values:", json);
      console.log("üîç Checking for rive_artboard:", json.rive_artboard);
      console.log("üîç Checking for rive_layout:", json.rive_layout);
      console.log("üîç All keys:", Object.keys(json));
      
      // Store initial values to apply after Rive loads
      window.pendingInitialValues = json;
      
      // Check if we need to set a different artboard from the start
      if (json.rive_artboard !== undefined) {
        const artboardIndex = parseInt(json.rive_artboard);
        console.log(`üéØ Initial artboard selection: index ${artboardIndex} (will apply after Rive loads)`);
      } else {
        console.log("‚ö†Ô∏è No rive_artboard found in init values");
      }
      
      // Apply initial values immediately if Rive is already loaded
      if (r && Object.keys(riveProps).length > 0) {
        console.log("üé¨ Applying initial values from SingularLive...");
        onSingularValue(json);
      } else {
        console.log("‚è≥ Rive not ready yet, will apply values on load");
      }
    }

    function onSingularValue(json) {
      console.log("Received values:", json);
      console.log("üîç rive_artboard in onValue:", json.rive_artboard);
      console.log("üîç rive_layout in onValue:", json.rive_layout);
      
      // Always update pending values with the latest data (merge with existing)
      if (window.pendingInitialValues) {
        window.pendingInitialValues = { ...window.pendingInitialValues, ...json };
      } else {
        window.pendingInitialValues = json;
      }
      
      // Handle Rive configuration changes
      let needsReload = false;
      let newArtboard = ARTBOARD_NAME;
      let newLayout = LAYOUT_FIT;
      let newFileUrl = r ? r.src : "test_file.riv";
      
      // Check for artboard change
      if (json.rive_artboard !== undefined) {
        const artboardIndex = parseInt(json.rive_artboard);
        try {
          const file = r.file;
          if (file && artboardIndex >= 0 && artboardIndex < file.artboardCount()) {
            const artboard = file.artboardByIndex(artboardIndex);
            if (artboard) {
              newArtboard = typeof artboard.name === 'function' ? artboard.name() : artboard.name;
            }
          } else {
            console.warn(`Invalid artboard index: ${artboardIndex}`);
          }
        } catch (err) {
          console.error("Error getting artboard name:", err);
        }
        
        if (newArtboard !== ARTBOARD_NAME) {
          console.log(`üéØ Artboard change: "${ARTBOARD_NAME}" ‚Üí "${newArtboard}"`);
          ARTBOARD_NAME = newArtboard;
          needsReload = true;
        }
      }
      
      // Check for layout change
      if (json.rive_layout !== undefined) {
        const layoutOptions = ["contain", "cover", "fill", "fitWidth", "fitHeight", "scaleDown", "layout", "none"];
        const layoutIndex = parseInt(json.rive_layout);
        newLayout = layoutOptions[layoutIndex] || "contain";
        
        if (newLayout !== LAYOUT_FIT) {
          console.log(`üìê Layout change: "${LAYOUT_FIT}" ‚Üí "${newLayout}"`);
          LAYOUT_FIT = newLayout;
          needsReload = true;
        }
      }
      
      // Check for file URL change
      if (json.rive_file_url !== undefined && json.rive_file_url !== newFileUrl) {
        console.log(`üìÅ File URL change: "${newFileUrl}" ‚Üí "${json.rive_file_url}"`);
        newFileUrl = json.rive_file_url;
        needsReload = true;
      }
      
      // Reload Rive if configuration changed
      if (needsReload) {
        console.log("üîÑ Reloading Rive with new configuration...");
        // Keep the latest values for after reload
        window.pendingInitialValues = json;
        reloadRive(newFileUrl, newArtboard, newLayout);
        return; // Don't process property updates yet, wait for reload
      }

      // Handle view model property updates
      for (const [name, prop] of Object.entries(riveProps)) {
        if (json[name] === undefined) continue;

        try {
          if (prop.type === "string" || prop.type === "number" || prop.type === "boolean") {
            const newValue = json[name];
            const currentValue = prop.accessor.value;
            if (newValue !== currentValue) {
              prop.accessor.value = newValue;
              console.log(`${name}: "${currentValue}" ‚Üí "${newValue}"`);
            }
          } 
          else if (prop.type === "color") {
            const colorData = json[name];
            // SingularLive sends color as {r, g, b, a} object
            if (colorData && typeof colorData === 'object' && 'r' in colorData) {
              const r = Math.round(colorData.r);
              const g = Math.round(colorData.g);
              const b = Math.round(colorData.b);
              const a = colorData.a !== undefined ? Math.round(colorData.a * 255) : 255;
              prop.accessor.rgba(r, g, b, a);
              console.log(`${name}: rgba(${r}, ${g}, ${b}, ${a})`);
            }
          }
        } catch (err) {
          console.error(`‚ùå Failed to update '${name}':`, err.message);
        }
      }
    }
    
    // Function to reload Rive with new configuration
    function reloadRive(fileUrl, artboardName, layoutFit) {
      // Clean up existing instance
      if (r) {
        try {
          r.cleanup();
        } catch (err) {
          console.warn("Error cleaning up Rive:", err);
        }
      }
      
      // Build new configuration
      const riveConfig = {
        src: fileUrl,
        canvas: document.getElementById("canvas"),
        autoplay: true,
        autoBind: true,
        stateMachines: STATE_MACHINE_NAME,
        layout: new rive.Layout({
          fit: rive.Fit[layoutFit.charAt(0).toUpperCase() + layoutFit.slice(1)] || rive.Fit.Contain
        }),
        onLoad: () => {
          console.log("‚úÖ Rive reloaded\n");
          
          listAllArtboards(r);
          
          console.log(`üìê Active artboard: ${r.activeArtboard?.name || 'default'}`);
          console.log(`üìê Active layout: ${layoutFit}`);
          resizeCanvas();
          
          if (r.viewModelCount === 0) {
            console.error("‚ùå No view models found in this artboard");
            return;
          }

          riveProps = GetAllViewModelProperties(r);
          
          if (Object.keys(riveProps).length === 0) {
            console.warn("‚ö†Ô∏è No properties found.");
          } else {
            console.log(`‚úÖ Reloaded with ${Object.keys(riveProps).length} properties`);
            // Generate new UI JSON for the new artboard's view models
            generateUIModel();
            
            // Apply pending initial values if they exist (from onInit)
            if (window.pendingInitialValues) {
              console.log("üé¨ Applying pending initial values after reload...");
              const initialValues = window.pendingInitialValues;
              window.pendingInitialValues = null; 
              onSingularValue(initialValues);
            }
          }
        },
        onLoadError: (err) => {
          console.error("‚ùå Rive reload error:", err);
        },
      };
      
      // Only add artboard property if a specific name is provided
      if (artboardName) {
        riveConfig.artboard = artboardName;
        console.log(`üéØ Targeting artboard: "${artboardName}"`);
      } else {
        console.log("üéØ Using default artboard");
      }
      
      r = new rive.Rive(riveConfig);
    }

    function onSingularButtonClicked(action) {
      const prop = riveProps[action];
      if (prop && prop.type === "trigger") {
        if (typeof prop.accessor.trigger === "function") {
          prop.accessor.trigger();
          console.log(`Triggered: ${action}`);
        }
      }
    }

    function onSingularEditComp(comp) {
      console.log("onSingularEditComp", comp);
    }
    
  </script>
</body>
</html>
