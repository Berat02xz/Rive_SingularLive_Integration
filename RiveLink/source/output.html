<!DOCTYPE html>
<html>
<head>
  <style>
    html, body { 
      background: none; 
      margin: 0; 
      padding: 0; 
      height: 100%; 
      width: 100%;
      overflow: hidden;
    }
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <!-- Rive runtime will be loaded dynamically: webgl2 or canvas -->

  <canvas id="canvas"></canvas>
  <script src="https://beta.singular.live/libs/singularwidget/1.0.4/singularwidget.js"></script>
  <script>
    let riveProps = {};
    let r = null;
    let ARTBOARD_NAME = "";
    let STATE_MACHINE_NAME = "State Machine 1";
    let LAYOUT_FIT = "contain";
    let CURRENT_FILE_URL = "";
    // Renderer selection: 'webgl2' (default) or 'canvas'
  let CURRENT_RUNTIME = null; // don't assume until first values arrive
  let HAS_INITIAL_VALUES = false;
  let INIT_DONE = false;
  const WIDGET_STATE = { fileUrl: '', layoutFit: 'contain', artboardIndex: 0, renderer: true };

    // Robust boolean coercion for values coming from Singular (can be boolean, string, number)
    function parseBool(value, defaultIfUndef = true) {
      if (value === undefined || value === null) return defaultIfUndef;
      if (typeof value === 'boolean') return value;
      if (typeof value === 'number') return value !== 0;
      if (typeof value === 'string') {
        const v = value.trim().toLowerCase();
        if (v === 'true' || v === '1' || v === 'on' || v === 'yes') return true;
        if (v === 'false' || v === '0' || v === 'off' || v === 'no') return false;
        return defaultIfUndef; // unknown strings fall back to default
      }
      return !!value;
    }
    const RUNTIME_SOURCES = {
      webgl2: 'https://unpkg.com/@rive-app/webgl2',
      canvas: 'https://unpkg.com/@rive-app/canvas'
    };
    const RUNTIME_SCRIPT_ID = 'rive-runtime-script';
    // Offscreen renderer is only relevant to webgl; enable as best-practice
    const USE_OFFSCREEN_RENDERER = true;

    // Dynamically load the desired Rive runtime
    function waitForRive(maxMs = 4000, intervalMs = 50) {
      return new Promise((resolve, reject) => {
        const start = Date.now();
        const timer = setInterval(() => {
          if (window.rive && typeof window.rive.Rive === 'function') {
            clearInterval(timer);
            resolve();
          } else if (Date.now() - start > maxMs) {
            clearInterval(timer);
            reject(new Error('Timed out waiting for rive global'));
          }
        }, intervalMs);
      });
    }

    function ensureRiveRuntime(desiredRuntime) {
      return new Promise((resolve, reject) => {
        if (CURRENT_RUNTIME === desiredRuntime && window.rive && typeof window.rive.Rive === 'function') {
          console.log(`üîµ Rive runtime already loaded: ${desiredRuntime}`);
          return resolve();
        }
        const existing = document.getElementById(RUNTIME_SCRIPT_ID);
        if (existing) {
          console.log('üîÑ Removing existing Rive runtime script');
          existing.remove();
        }
        try { delete window.rive; } catch {}
        const script = document.createElement('script');
        script.id = RUNTIME_SCRIPT_ID;
        script.src = RUNTIME_SOURCES[desiredRuntime];
        script.onload = () => {
          waitForRive().then(() => {
            CURRENT_RUNTIME = desiredRuntime;
            console.log(`‚úÖ Loaded Rive runtime: ${desiredRuntime}`);
            resolve();
          }).catch((e) => {
            console.error('‚ùå rive global not ready after script load', e);
            reject(e);
          });
        };
        script.onerror = (e) => {
          console.error('‚ùå Failed to load Rive runtime', desiredRuntime, e);
          reject(e);
        };
        document.body.prepend(script);
      });
    }
    
    function resizeCanvas() {
      const canvas = document.getElementById("canvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (r) r.resizeDrawingSurfaceToCanvas();
    }
    
    window.addEventListener('resize', resizeCanvas);

    function getArtboardName(artboard) {
      return typeof artboard.name === 'function' ? artboard.name() : artboard.name;
    }

    // collect properties from a view model
    function collectProperties(vmi, viewModel, props, pathPrefix = "") {
      if (!viewModel.properties?.length) return;

      for (const property of viewModel.properties) {
        if (!property?.name || property.type === "viewModel") continue;
        
        const propertyPath = pathPrefix ? `${pathPrefix}/${property.name}` : property.name;
        let accessor = null;
        
        try {
          switch(property.type) {
            case "string":  accessor = vmi.string(propertyPath); break;
            case "number":  accessor = vmi.number(propertyPath); break;
            case "boolean": accessor = vmi.boolean(propertyPath); break;
            case "trigger": accessor = vmi.trigger(propertyPath); break;
            case "color":   accessor = vmi.color(propertyPath); break;
            case "enum":    accessor = vmi.enum(propertyPath); break;
          }
        } catch (err) {
          console.error(`Error accessing '${propertyPath}':`, err.message);
        }

        if (accessor) {
          const propKey = propertyPath.replace(/\//g, '_');
          props[propKey] = { type: property.type, accessor, path: propertyPath };
        }
      }
    }

    // Get all view models and collect their properties
    function GetAllViewModelProperties(rive) {
      const props = {};
      const vmi = rive.viewModelInstance;
      const defaultVM = rive.defaultViewModel();
      
      if (!defaultVM) {
        console.error("No default view model");
        return props;
      }

      // collect properties from the default view model
      collectProperties(vmi, defaultVM, props, "");
      
      const processedVMs = new Set([defaultVM]);
      
      // Iterate over properties to find nested view models
      for (const prop of defaultVM.properties) {
        if (prop?.type === "viewModel" && prop.name) {
          let matchedVM = null;
          
          for (let i = 0; i < rive.viewModelCount; i++) {
            const vm = rive.viewModelByIndex(i);
            if (!vm || processedVMs.has(vm)) continue;
            if (vm.name && prop.name.includes(vm.name)) {
              matchedVM = vm;
              break;
            }
          }
          
          if (!matchedVM) {
            for (let i = 0; i < rive.viewModelCount; i++) {
              const vm = rive.viewModelByIndex(i);
              if (vm && !processedVMs.has(vm)) {
                matchedVM = vm;
                break;
              }
            }
          }
           
          if (matchedVM) {
            processedVMs.add(matchedVM);
            // collect properties from a nested view model
            collectProperties(vmi, matchedVM, props, prop.name);
          }
        }
      }
      
      return props;
    }
    
    // Initialize Singular Widget first (wait for initial values to decide runtime)
    SingularWidget.init({
      onInit: (json) => {
        window.pendingInitialValues = json;
        console.log('‚è≥ onInit: waiting for first values to choose runtime...');
        // Fallback: if onValue doesn't arrive soon, apply onInit values
        setTimeout(async () => {
          if (HAS_INITIAL_VALUES || INIT_DONE) return;
          try {
            const useWebGL2 = parseBool(json.rive_renderer, true); // treat undefined as true
            const desiredRuntime = useWebGL2 ? 'webgl2' : 'canvas';
            console.log('üü° onInit fallback: ensuring runtime', desiredRuntime);
            await ensureRiveRuntime(desiredRuntime);
            if (typeof json.rive_file_url === 'string' && json.rive_file_url.endsWith('.riv')) {
              CURRENT_FILE_URL = json.rive_file_url;
              INIT_DONE = true;
              initializeRive(json.rive_file_url);
            } else {
              console.log('üü° onInit fallback: no valid .riv url yet');
            }
          } catch (e) {
            console.error('‚ùå onInit fallback failed:', e);
          }
        }, 500);
      },
      onValue: onSingularValue,
      onButtonClicked: onSingularButtonClicked,
      onAnimation: onSingularAnimation,
    });
    
    // Initialize Rive with a given file URL
    function initializeRive(fileUrl) {
      const riveConfig = {
        src: fileUrl,
        canvas: document.getElementById("canvas"),
        autoplay: true, // Keep autoplay for state machines to process view model updates
        autoBind: true,
        ...(CURRENT_RUNTIME === 'webgl2' ? { useOffscreenRenderer: USE_OFFSCREEN_RENDERER } : {}),
        // apply current layout fit on initial load as well
        layout: (window.rive && rive && rive.Layout) ? new rive.Layout({
          fit: rive.Fit[LAYOUT_FIT.charAt(0).toUpperCase() + LAYOUT_FIT.slice(1)] || rive.Fit.Contain
        }) : undefined,
        onLoad: () => {
          console.log("‚úÖ Rive loaded successfully, src:", fileUrl);
          resizeCanvas();
          detectInOutTimelines();
          
          // Try to find a Rive state machine
          if (r.stateMachineNames && r.stateMachineNames.length > 0) {
            STATE_MACHINE_NAME = r.stateMachineNames[0];
            console.log("üîµ Found Rive state machine:", STATE_MACHINE_NAME);
          } else {
            console.warn("‚ö†Ô∏è No Rive state machines found in this file");
            STATE_MACHINE_NAME = "";
          }
          
          if (r.viewModelCount === 0) {
            console.log("‚ö†Ô∏è No Rive view models found in Rive file");
            // Still generate UI even without Rive view models (a.k.a only artboard selection)
            generateUIModel();
            return;
          }

          console.log("üîµ Getting Rive view model properties...");
          riveProps = GetAllViewModelProperties(r);
          console.log("üîµ Found", Object.keys(riveProps).length, "Rive properties");
          generateUIModel();
        
          if (window.pendingInitialValues) {
            const initialValues = window.pendingInitialValues;
            window.pendingInitialValues = null;
            onSingularValue(initialValues);
          }
        },
        onLoadError: (err) => {
          console.error("‚ùå Rive load error:", err);
          // Still try to generate basic UI
          generateUIModel();
        }
      };
    
      if (ARTBOARD_NAME) {
        console.log("üîµ Setting artboard:", ARTBOARD_NAME);
        riveConfig.artboard = ARTBOARD_NAME;
      }

      // Only add Rive stateMachines if we know the name
      if (STATE_MACHINE_NAME) {
        riveConfig.stateMachines = STATE_MACHINE_NAME;
      }
      
      console.log("üîµ Creating new Rive instance with runtime:", CURRENT_RUNTIME);
      r = new rive.Rive(riveConfig);
      INIT_DONE = true;
    }

    // Generate Dynamic UI model for Singular Widget
    function generateUIModel() {
      const fields = [];
      const groupedProperties = {};
      
      // Generate alphanumeric ID from a string
      function toAlphanumericId(str) {
        return str.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
      }
      
      // Get available artboards from the Rive file
      const availableArtboards = [];
      const file = r.file;
      let currentArtboardIndex = 0;
      
      if (file) {
        const artboardCount = file.artboardCount();
        for (let i = 0; i < artboardCount; i++) {
          const artboard = file.artboardByIndex(i);
          if (artboard) {
            const artboardName = getArtboardName(artboard);
            availableArtboards.push(artboardName);
            
            // Check if this is the current artboard
            if (ARTBOARD_NAME && artboardName === ARTBOARD_NAME) {
              currentArtboardIndex = i;
            } else if (!ARTBOARD_NAME && i === 0) {
              // If no artboard is set, default to the first one
              currentArtboardIndex = 0;
            }
          }
        }
      }
      
      // Add artboard selection field
      if (availableArtboards.length > 0) {
        fields.push({
          id: "riveartboard",
          type: "selection",
          title: "Artboard",
          defaultValue: currentArtboardIndex.toString(),
          selections: availableArtboards.map((name, index) => ({
            id: index.toString(),
            title: name
          }))
        });
      }
      
      // for each property, create a UI field
      for (const [name, prop] of Object.entries(riveProps)) {
        // if a property ends with __, skip it (a way to name properties like that to hide them from singular)
        if (name.endsWith('__')) continue;
        
        const displayName = name.includes('_') ? name.split('_').pop() : name;
        
        let viewModelName = "Root View Model";
        
        if (name.includes('_')) {
          const parts = name.split('_');
          parts.pop();
          viewModelName = parts.join(' ').replace(/^property of /i, '');
        }
        
        let fieldType = prop.type;
        let defaultValue = "";
        
        if (prop.type === "trigger") {
          fieldType = "button";
        } else if (prop.type === "string") {
          fieldType = "text";
          defaultValue = prop.accessor.value || "";
        } else if (prop.type === "number") {
          defaultValue = prop.accessor.value || 0;
        } else if (prop.type === "boolean") {
          fieldType = "checkbox";
          defaultValue = prop.accessor.value || false;
        } else if (prop.type === "color") {
          const colorValue = prop.accessor.value;
          defaultValue = {
            r: (colorValue >> 16) & 0xFF,
            g: (colorValue >> 8) & 0xFF,
            b: colorValue & 0xFF,
            a: ((colorValue >> 24) & 0xFF) / 255
          };
        }
        
        // Use alphanumeric ID for dynamic fields
        const fieldId = toAlphanumericId(name);
        
        fields.push({
          id: fieldId,
          type: fieldType,
          title: displayName.charAt(0).toUpperCase() + displayName.slice(1),
          defaultValue: defaultValue
        });
        
        if (!groupedProperties[viewModelName]) {
          groupedProperties[viewModelName] = [];
        }
        groupedProperties[viewModelName].push(fieldId);
      }

      const groups = [];
      
      // Add artboard group at the top
      if (availableArtboards.length > 0) {
        groups.push({
          id: "artboardgroup",
          title: "Artboard Selection",
          width: "double",
          toolTip: "Select the artboard to display",
          childIds: ["riveartboard"]
        });
      }
      
      // Add other property groups
      for (const [vmName, childIds] of Object.entries(groupedProperties)) {
        groups.push({
          id: toAlphanumericId(vmName) + "group",
          title: vmName,
          width: "double",
          toolTip: `Properties from ${vmName}`,
          childIds: childIds
        });
      }

      // Set dynamic UI using SingularWidget.setCustomWidgetUI
      if (typeof SingularWidget.setCustomWidgetUI === 'function') {
        const res = SingularWidget.setCustomWidgetUI({
          fields: fields,
          groups: groups
        });
        
        // Check the response to see if it worked
        console.log("üì• Dynamic UI Response:", JSON.stringify(res, null, 2));
        
        if (res && res.success === false) {
          console.error("‚ùå Failed to set dynamic UI:");
          console.error("Error message:", res.message || res.error || "Unknown error");
          console.error("Full response:", res);
        } else if (res && res.success === true) {
          console.log("‚úÖ Dynamic UI created successfully!");
        } else {
          console.warn("‚ö†Ô∏è Unexpected response format:", res);
        }
      } else {
        console.error("‚ùå SingularWidget.setCustomWidgetUI is not available. Please update the Singular Widget SDK to the latest version.");
        console.log("üìã Copy the following model to the Widget Manager UI:");
        console.log(JSON.stringify({ model: { fields, groups } }, null, 2));
      }
      
      // Also log to console for reference
      console.log("\nüìã Dynamic UI Configuration:");
      console.log(JSON.stringify({ fields, groups }, null, 2));
    }

    // Generate alphanumeric ID from a string (utility function)
    function toAlphanumericId(str) {
      return str.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
    }
    
    // Handle singular value change
    // if a value such as artboard or layout changes, then it reloads Rive (required)
    async function onSingularValue(json) {
      console.log("üîµ onSingularValue called with:", json);
      
      window.pendingInitialValues = window.pendingInitialValues 
        ? { ...window.pendingInitialValues, ...json } 
        : json;

      // Check for runtime change first and ensure it's loaded
      if (json.rive_renderer !== undefined) {
        const desiredRenderer = parseBool(json.rive_renderer, true);
        const desiredRuntime = desiredRenderer ? 'webgl2' : 'canvas';
        
        if (!HAS_INITIAL_VALUES) {
          HAS_INITIAL_VALUES = true;
          console.log(`üü¢ Initial values received; desired runtime: ${desiredRuntime}`);
        }
        
        const runtimeChanged = (CURRENT_RUNTIME && CURRENT_RUNTIME !== desiredRuntime);
        const needRuntimeLoad = !CURRENT_RUNTIME || runtimeChanged || !(window.rive && typeof window.rive.Rive === 'function');

        if (needRuntimeLoad) {
          console.log(`üîµ Ensuring runtime '${desiredRuntime}' is loaded... (current: ${CURRENT_RUNTIME || 'none'})`);
          // If switching runtime and an instance exists, cleanup before removing global
          if (runtimeChanged && r) {
            try {
              console.log('üßπ Cleaning up existing Rive instance before runtime switch');
              r.cleanup();
            } catch (e) {
              console.warn('‚ö†Ô∏è Cleanup error before runtime switch:', e);
            }
            r = null;
          }
          try {
            await ensureRiveRuntime(desiredRuntime);
          } catch (e) {
            console.error('‚ùå Failed to load desired runtime:', desiredRuntime, e);
            return;
          }
        }
      }

      // Handle file URL change - if it ends with .riv, load it immediately
      if (json.rive_file_url !== undefined) {
        console.log("üîµ File URL change detected:", json.rive_file_url);
        
        if (typeof json.rive_file_url === 'string' && json.rive_file_url.endsWith('.riv')) {
          const newFileUrl = json.rive_file_url;
          
          if (newFileUrl !== CURRENT_FILE_URL) {
            console.log("‚úÖ Valid .riv file, loading:", newFileUrl);
            CURRENT_FILE_URL = newFileUrl;
            
            // Get layout if available
            let layoutFit = LAYOUT_FIT;
            if (json.rive_layout !== undefined) {
              const layoutOptions = ["contain", "cover", "fill", "fitWidth", "fitHeight", "scaleDown", "layout", "none"];
              layoutFit = layoutOptions[parseInt(json.rive_layout)] || "contain";
              LAYOUT_FIT = layoutFit;
            }
            
            // Reset artboard and state machine for new file
            ARTBOARD_NAME = "";
            STATE_MACHINE_NAME = "";
            
            // If no instance yet, initialize; otherwise reload
            if (!r) {
              initializeRive(newFileUrl);
            } else {
              reloadRive(newFileUrl, ARTBOARD_NAME, layoutFit);
            }
            return;
          } else {
            console.log("üîµ Same .riv file, no reload needed");
          }
        } else {
          console.log("‚ö†Ô∏è File does not end with .riv:", json.rive_file_url);
          return; // Don't process further if URL is invalid
        }
      }
      
      // If we don't have a Rive instance yet but we have a valid URL, initialize it
      if (!r && CURRENT_FILE_URL && CURRENT_FILE_URL.endsWith('.riv')) {
        console.log("üîµ No instance yet, initializing with:", CURRENT_FILE_URL);
        initializeRive(CURRENT_FILE_URL);
        return;
      }
      
      // Handle layout change
      if (json.rive_layout !== undefined) {
        const layoutOptions = ["contain", "cover", "fill", "fitWidth", "fitHeight", "scaleDown", "layout", "none"];
        const newLayout = layoutOptions[parseInt(json.rive_layout)] || "contain";
        if (newLayout !== LAYOUT_FIT) {
          console.log("üîµ Layout changed from", LAYOUT_FIT, "to", newLayout);
          LAYOUT_FIT = newLayout;
          if (r && CURRENT_FILE_URL) {
            reloadRive(CURRENT_FILE_URL, ARTBOARD_NAME, newLayout);
            return;
          }
        }
      }
      
      // Handle dynamic artboard field (riveartboard) from dynamic UI
      if (json.riveartboard !== undefined && r) {
        console.log("ÔøΩ Artboard change requested:", json.riveartboard);
        const artboardIndex = parseInt(json.riveartboard);
        const file = r?.file;
        if (file && artboardIndex >= 0 && artboardIndex < file.artboardCount()) {
          const artboard = file.artboardByIndex(artboardIndex);
          if (artboard) {
            const newArtboard = getArtboardName(artboard);
            if (newArtboard !== ARTBOARD_NAME) {
              console.log("üîµ Artboard changed from", ARTBOARD_NAME, "to", newArtboard);
              ARTBOARD_NAME = newArtboard;
              if (CURRENT_FILE_URL) {
                reloadRive(CURRENT_FILE_URL, ARTBOARD_NAME, LAYOUT_FIT);
                return;
              }
            }
          }
        }
      }
      
      // Don't process dynamic field updates if we don't have a valid Rive file loaded
      if (!r) {
        console.log("‚ö†Ô∏è No Rive instance loaded");
        return;
      }

      // Handle dynamic field updates - map alphanumeric IDs back to property names
      for (const [name, prop] of Object.entries(riveProps)) {
        const alphanumericId = toAlphanumericId(name);
        if (json[alphanumericId] === undefined) continue;

        try {
          if (prop.type === "string" || prop.type === "number" || prop.type === "boolean") {
            const newValue = json[alphanumericId];
            if (newValue !== prop.accessor.value) {
              prop.accessor.value = newValue;
            }
          } else if (prop.type === "color") {
            const colorData = json[alphanumericId];
            if (colorData && typeof colorData === 'object' && 'r' in colorData) {
              const r = Math.round(colorData.r);
              const g = Math.round(colorData.g);
              const b = Math.round(colorData.b);
              const a = colorData.a !== undefined ? Math.round(colorData.a * 255) : 255;
              prop.accessor.rgba(r, g, b, a);
            }
          }
        } catch (err) {
          console.error(`‚ùå Failed to update '${name}' (id: ${alphanumericId}):`, err.message);
        }
      }
    }
    
    function reloadRive(fileUrl, artboardName, layoutFit) {
      console.log("üîÑ reloadRive called with:", { fileUrl, artboardName, layoutFit });
      if (r) {
        try {
          console.log("üîµ Cleaning up existing Rive instance...");
          r.cleanup();
        } catch (err) {
          console.warn("‚ö†Ô∏è Error cleaning up Rive:", err);
        }
      }
      
      const riveConfig = {
        src: fileUrl,
        canvas: document.getElementById("canvas"),
        autoplay: true, // Keep autoplay for state machines to process view model updates
        autoBind: true,
        ...(CURRENT_RUNTIME === 'webgl2' ? { useOffscreenRenderer: USE_OFFSCREEN_RENDERER } : {}),
        layout: new rive.Layout({
          fit: rive.Fit[layoutFit.charAt(0).toUpperCase() + layoutFit.slice(1)] || rive.Fit.Contain
        }),
        onLoad: () => {
          console.log("‚úÖ Rive reloaded successfully");
          resizeCanvas();
          detectInOutTimelines();
          
          // Try to find a state machine
          if (r.stateMachineNames && r.stateMachineNames.length > 0) {
            STATE_MACHINE_NAME = r.stateMachineNames[0];
            console.log("üîµ Found state machine:", STATE_MACHINE_NAME);
          } else {
            console.warn("‚ö†Ô∏è No state machines found in this Rive file");
            STATE_MACHINE_NAME = "";
          }
          
          if (r.viewModelCount === 0) {
            console.log("‚ö†Ô∏è No view models found in reloaded Rive file");
            // Still generate UI even without view models
            return;
          }

          riveProps = GetAllViewModelProperties(r);
          generateUIModel();
            
          if (window.pendingInitialValues) {
            const initialValues = window.pendingInitialValues;
            window.pendingInitialValues = null;
            onSingularValue(initialValues);
          }
        },
        onLoadError: (err) => {
          console.error("‚ùå Rive reload error:", err);
          // Still try to generate basic UI
          generateUIModel();
        }
      };
      
      if (artboardName) {
        console.log("üîµ Setting artboard for reload:", artboardName);
        riveConfig.artboard = artboardName;
      }
      
      // Only add stateMachines if we know the name
      if (STATE_MACHINE_NAME) {
        riveConfig.stateMachines = STATE_MACHINE_NAME;
      }
      
      console.log("üîµ Creating new Rive instance for reload with runtime:", CURRENT_RUNTIME);
      r = new rive.Rive(riveConfig);
    }

    // ---- In/Out timeline detection & playback integration ----
    let HAS_IN_TIMELINE = false;
    let HAS_OUT_TIMELINE = false;
    let IN_DURATION = null;
    let OUT_DURATION = null;

    function detectInOutTimelines() {
      if (!r) return;
      try {
        // Prefer enumerating animations from the artboard for reliability
        const names = new Set();
        const file = r.file;
        if (file) {
          // Determine current artboard name or fallback to default
            let artboard = null;
            if (ARTBOARD_NAME) {
              // Try exact match first
              for (let i = 0; i < file.artboardCount(); i++) {
                const ab = file.artboardByIndex(i);
                if (ab && (typeof ab.name === 'function' ? ab.name() : ab.name) === ARTBOARD_NAME) {
                  artboard = ab; break;
                }
              }
            }
            if (!artboard) artboard = file.artboardByIndex(0);
            if (artboard && artboard.animationCount) {
              for (let i = 0; i < artboard.animationCount(); i++) {
                const anim = artboard.animationByIndex(i);
                if (!anim) continue;
                const animName = typeof anim.name === 'function' ? anim.name() : anim.name;
                names.add(animName);
                if (animName === 'In') IN_DURATION = typeof anim.duration === 'function' ? anim.duration() : anim.duration;
                if (animName === 'Out') OUT_DURATION = typeof anim.duration === 'function' ? anim.duration() : anim.duration;
              }
            }
        }
        // Fallback to runtime's animationNames array if present
        if (r.animationNames && r.animationNames.length) {
          r.animationNames.forEach(n => names.add(n));
        }
        HAS_IN_TIMELINE = names.has('In');
        HAS_OUT_TIMELINE = names.has('Out');
        console.log(`üîç Timeline scan: In=${HAS_IN_TIMELINE} (${IN_DURATION ?? 'n/a'}s) Out=${HAS_OUT_TIMELINE} (${OUT_DURATION ?? 'n/a'}s) names=[${[...names].join(', ')}]`);
        flushPendingTimelineEvents();
      } catch (e) {
        console.warn('‚ö†Ô∏è Unable to inspect animation timelines', e);
      }
    }

    function playTimeline(name) {
      if (!r) return console.warn('‚ö†Ô∏è playTimeline called with no Rive instance');
      
      // Verify animation exists by checking artboard directly
      let found = false;
      try {
        const file = r.file;
        if (file) {
          // Check current artboard or default
          let artboard = null;
          if (ARTBOARD_NAME) {
            for (let i = 0; i < file.artboardCount(); i++) {
              const ab = file.artboardByIndex(i);
              if (ab && (typeof ab.name === 'function' ? ab.name() : ab.name) === ARTBOARD_NAME) {
                artboard = ab; break;
              }
            }
          }
          if (!artboard) artboard = file.artboardByIndex(0);
          
          if (artboard && artboard.animationCount) {
            for (let i = 0; i < artboard.animationCount(); i++) {
              const anim = artboard.animationByIndex(i);
              const animName = typeof anim.name === 'function' ? anim.name() : anim.name;
              if (animName === name) { 
                found = true; 
                break; 
              }
            }
          }
        }
      } catch (e) {
        console.warn('‚ö†Ô∏è Error checking animation existence:', e);
      }
      
      if (!found) {
        console.warn(`‚ö†Ô∏è Requested timeline '${name}' not found in current artboard`);
        return;
      }
      
      try {
        // Stop state machines first (they can block timeline playback)
        if (r.stateMachineInputs) {
          r.stop(); // stop everything including state machines
        } else {
          r.pause(); // just pause animations
        }
        
        // Play the timeline animation
        r.play([name]); // pass array of animation names
        console.log(`üé¨ Playing Rive timeline '${name}'`);
        
        // Log current state for debugging
        setTimeout(() => {
          console.log(`üîç Rive playback state: playing=${r.isPlaying}, paused=${r.isPaused}`);
        }, 50);
      } catch (e) {
        console.error(`‚ùå Failed to play timeline '${name}'`, e);
      }
    }

    // queue animation events arriving before Rive load / detection
    const pendingTimelineEvents = [];
    function flushPendingTimelineEvents() {
      if (!r) return;
      if (!HAS_IN_TIMELINE && !HAS_OUT_TIMELINE) return; // still nothing to process
      if (!pendingTimelineEvents.length) return;
      console.log(`üü® Flushing ${pendingTimelineEvents.length} pending animation events`);
      const toProcess = [...pendingTimelineEvents];
      pendingTimelineEvents.length = 0;
      toProcess.forEach(ev => {
        if (ev.timeline === 'In' && HAS_IN_TIMELINE) playTimeline('In');
        if (ev.timeline === 'Out' && HAS_OUT_TIMELINE) playTimeline('Out');
      });
    }

    // Callback from Singular when composition animation events occur
    function onSingularAnimation(evt) {
      // evt.timeline should be 'In' or 'Out' (and possibly others). Map directly.
      console.log('üéØ onSingularAnimation event:', evt);
      if (!evt || !evt.timeline) return;
      
      // Handle 'stop' event - resume state machine after timeline finishes
      if (evt.event === 'stop') {
        console.log(`üîÑ Timeline '${evt.timeline}' stopped, resuming state machine`);
        if (r && STATE_MACHINE_NAME) {
          try {
            r.stop(); // stop timeline
            r.play(STATE_MACHINE_NAME); // resume state machine
            console.log(`‚úÖ Resumed state machine: ${STATE_MACHINE_NAME}`);
          } catch (e) {
            console.warn('‚ö†Ô∏è Failed to resume state machine:', e);
          }
        }
        return;
      }
      
      // Only respond to 'start' events for playing timelines
      if (evt.event !== 'start') {
        console.log(`‚ÑπÔ∏è Ignoring event type '${evt.event}' (only processing 'start' and 'stop')`);
        return;
      }
      
      // If timelines not detected yet, queue
      if (!r || (!HAS_IN_TIMELINE && !HAS_OUT_TIMELINE)) {
        console.log('‚è≥ Queuing animation event until timelines detected');
        pendingTimelineEvents.push(evt);
        return;
      }
      
      // Use newState to determine which timeline to play (In or Out)
      // newState can be 'In', 'Out', 'Out1', 'Out2', etc.
      const targetTimeline = evt.newState || evt.timeline;
      console.log(`üéØ Target timeline from newState/timeline: '${targetTimeline}'`);
      
      // Map any state starting with 'Out' to the 'Out' timeline
      if (targetTimeline === 'In' && HAS_IN_TIMELINE) {
        playTimeline('In');
      } else if (targetTimeline && targetTimeline.startsWith('Out') && HAS_OUT_TIMELINE) {
        playTimeline('Out');
      } else {
        console.log(`‚ÑπÔ∏è Timeline '${targetTimeline}' not mapped (In:${HAS_IN_TIMELINE} Out:${HAS_OUT_TIMELINE})`);
      }
    }

    // Handle button clicks from Singular Widget
    function onSingularButtonClicked(action) {
      console.log('üîò onSingularButtonClicked:', action);
      
      // Ensure state machine is running for triggers to work
      if (r && STATE_MACHINE_NAME) {
        try {
          // Check if state machine is playing, if not restart it
          if (!r.isPlaying || r.isPaused) {
            console.log('üîÑ State machine not running, restarting for trigger');
            r.play(STATE_MACHINE_NAME);
          }
        } catch (e) {
          console.warn('‚ö†Ô∏è Could not check/restart state machine:', e);
        }
      }
      
      // Map alphanumeric ID back to property name
      for (const [name, prop] of Object.entries(riveProps)) {
        const alphanumericId = toAlphanumericId(name);
        if (alphanumericId === action && prop?.type === "trigger" && typeof prop.accessor.trigger === "function") {
          console.log(`üîò Firing trigger: ${name}`);
          prop.accessor.trigger();
          return;
        }
      }
      
      console.warn(`‚ö†Ô∏è Button action '${action}' not found in riveProps`);
    }
    
  </script>
</body>
</html>
