<!DOCTYPE html>
<html>
<head>
  <style>
    html, body { background: none; margin: 0; padding: 0; height: 100%; }
  </style>
</head>
<body>
  <script src="https://unpkg.com/@rive-app/webgl2"></script>

  <canvas id="canvas" width="1920" height="1080"></canvas>

  <script src="https://libs.singular.live/singularwidget/1.0.3/singularwidget.js"></script>
  <script>
    let riveProps = {};
    let r = null;

    // Simple, non-recursive property collection
    function collectProperties(vmi, viewModel, props, pathPrefix = "") {
      const properties = viewModel.properties;
      if (!properties || !properties.length) return;

      for (const property of properties) {
        if (!property || !property.name) continue;
        
        // Skip nested view model properties - they're just references, not actual data
        if (property.type === "viewModel") {
          console.log(`  üîó Skipping nested VM reference: ${property.name}`);
          continue;
        }
        
        // Build the path for accessing this property
        const propertyPath = pathPrefix ? `${pathPrefix}/${property.name}` : property.name;
        
        // Create accessor for this property
        let accessor = null;
        try {
          switch(property.type) {
            case "string":   accessor = vmi.string(propertyPath); break;
            case "number":   accessor = vmi.number(propertyPath); break;
            case "boolean":  accessor = vmi.boolean(propertyPath); break;
            case "trigger":  accessor = vmi.trigger(propertyPath); break;
            case "color":    accessor = vmi.color(propertyPath); break;
            case "enum":     accessor = vmi.enum(propertyPath); break;
          }
        } catch (err) {
          console.error(`  ‚ùå Error accessing '${propertyPath}':`, err.message);
        }

        if (accessor) {
          // Use safe key name for SingularLive (replace / with _)
          const propKey = propertyPath.replace(/\//g, '_');
          props[propKey] = { 
            type: property.type, 
            accessor,
            path: propertyPath
          };
          console.log(`  ‚úÖ ${propKey} (${property.type})`);
        }
      }
    }

    // Collect all properties from all view models
    function GetAllViewModelProperties(rive) {
      const props = {};
      
      console.log(`üîç Found ${rive.viewModelCount} view model(s)`);
      
      const vmi = rive.viewModelInstance;
      if (!vmi) {
        console.error("‚ùå No view model instance - autoBind must be true");
        return props;
      }
      
      const defaultVM = rive.defaultViewModel();
      if (!defaultVM) {
        console.error("‚ùå No default view model");
        return props;
      }
      
      console.log(`\nüìã Root VM: ${defaultVM.name || 'Unnamed'}`);
      
      // First: Collect properties from root view model
      collectProperties(vmi, defaultVM, props, "");
      
      // Second: Find nested VM properties and collect from ALL nested VMs
      const rootProperties = defaultVM.properties;
      const processedVMs = new Set([defaultVM]); // Track which VMs we've processed
      
      for (const prop of rootProperties) {
        if (prop && prop.type === "viewModel" && prop.name) {
          console.log(`\nüîó Found nested VM property: "${prop.name}"`);
          
          // Try to match this property to a specific view model
          // The property name might contain the VM name (e.g., "property of View Model 2")
          let matchedVM = null;
          
          for (let i = 0; i < rive.viewModelCount; i++) {
            const vm = rive.viewModelByIndex(i);
            if (!vm || processedVMs.has(vm)) continue;
            
            // Check if the property name contains this VM's name
            if (vm.name && prop.name.includes(vm.name)) {
              matchedVM = vm;
              break;
            }
          }
          
          // If no match by name, just take the next unprocessed VM
          if (!matchedVM) {
            for (let i = 0; i < rive.viewModelCount; i++) {
              const vm = rive.viewModelByIndex(i);
              if (vm && !processedVMs.has(vm)) {
                matchedVM = vm;
                break;
              }
            }
          }
          
          if (matchedVM) {
            console.log(`üìã Nested VM: ${matchedVM.name || 'Unnamed'}`);
            processedVMs.add(matchedVM);
            // Collect properties using the nested property name as path prefix
            collectProperties(vmi, matchedVM, props, prop.name);
          }
        }
      }
      
      console.log(`\n‚úÖ Total properties collected: ${Object.keys(props).length}`);
      return props;
    }

    // Initialize Rive
    r = new rive.Rive({
      src: "test_file.riv",
      canvas: document.getElementById("canvas"),
      autoplay: true,
      autoBind: true,
      stateMachines: "State Machine 1",
      onLoad: () => {
        console.log("‚úÖ Rive loaded\n");
        r.resizeDrawingSurfaceToCanvas();
        
        if (r.viewModelCount === 0) {
          console.error("‚ùå No view models in file");
          return;
        }

        riveProps = GetAllViewModelProperties(r);
        generateModelForManualSetup();
      },
    });

    // Generate JSON for Widget Manager
    function generateModelForManualSetup() {
      const fields = [];
      
      for (const [name, prop] of Object.entries(riveProps)) {
        // Extract just the property name (after the last underscore if it exists)
        // e.g., "property of View Model 3_TEST" -> "TEST"
        const displayName = name.includes('_') ? name.split('_').pop() : name;
        
        fields.push({
          id: name,
          type: prop.type === "trigger" ? "button" : prop.type === "string" ? "text" : prop.type,
          title: displayName.charAt(0).toUpperCase() + displayName.slice(1),
          defaultValue: prop.type === "trigger" ? "" : prop.accessor.value || (prop.type === "number" ? 0 : prop.type === "boolean" ? false : "")
        });
      }

      const model = { 
        model: { 
          fields, 
          groups: [{
            id: "riveControlsGroup",
            title: "Rive Controls",
            width: "double",
            toolTip: "Control your Rive animation properties",
            childIds: fields.map(f => f.id)
          }]
        }
      };

      console.log("\nüìã COPY TO WIDGET MANAGER:");
      console.log("=".repeat(60));
      console.log(JSON.stringify(model, null, 2));
      console.log("=".repeat(60));
    }

    // SingularLive Widget Integration
    SingularWidget.init({
      onInit: onSingularInit,
      onValue: onSingularValue,
      onButtonClicked: onSingularButtonClicked,
      onEditComp: onSingularEditComp,
    });

    function onSingularInit() {
      console.log("SingularWidget initialized");
    }

    function onSingularValue(json) {
      console.log("Received values:", json);

      for (const [name, prop] of Object.entries(riveProps)) {
        if (json[name] === undefined) continue;

        try {
          if (prop.type === "string") {
            const newValue = json[name];
            const currentValue = prop.accessor.value;
            if (newValue !== currentValue) {
              prop.accessor.value = newValue;
              console.log(`üìù ${name}: "${currentValue}" ‚Üí "${newValue}"`);
            }
          } 
          else if (prop.type === "number") {
            const newValue = parseFloat(json[name]);
            const currentValue = prop.accessor.value;
            if (newValue !== currentValue) {
              prop.accessor.value = newValue;
              console.log(`üî¢ ${name}: ${currentValue} ‚Üí ${newValue}`);
            }
          } 
          else if (prop.type === "boolean") {
            const newValue = !!json[name];
            const currentValue = prop.accessor.value;
            if (newValue !== currentValue) {
              prop.accessor.value = newValue;
              console.log(`üü¢ ${name}: ${currentValue} ‚Üí ${newValue}`);
            }
          }
        } catch (err) {
          console.error(`‚ùå Failed to update '${name}':`, err.message);
        }
      }
    }

    function onSingularButtonClicked(action) {
      const prop = riveProps[action];
      if (prop && prop.type === "trigger") {
        if (typeof prop.accessor.trigger === "function") {
          prop.accessor.trigger();
          console.log(`üöÄ Triggered: ${action}`);
        }
      }
    }

    function onSingularEditComp(comp) {
      console.log("onSingularEditComp", comp);
    }
    
  </script>
</body>
</html>
