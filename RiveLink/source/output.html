<!doctype html>
<html>
  <head>
    <style>
      html,
      body {
        background: none;
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
      }
      #canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <!-- FPS Counter Overlay (use when in development) -->
    <div id="rive-fps-counter" style="display: none; position: absolute; top: 12px; left: 12px; background-color: black; color: white; font: 20px Gotham, sans-serif; border-radius: 8px; padding: 8px 12px; z-index: 1000;"> FPS: -- </div>

    <script src="https://beta.singular.live/libs/singularwidget/1.0.4/singularwidget.js"></script>

    <script>
      const widgetState = {
        riveProps: {},
        r: null,
        artboardName: "",
        stateMachineName: "",
        layoutFit: "",
        fileUrl: "",
        runtime: "",
        stateMachineIndex: 0,
        displayFpsCounter: false,
        layoutOptions: [ "Contain", "Cover", "Fill", "FitWidth", "FitHeight", "ScaleDown", "Layout", "None", ],
        runtimeSources: {
          webgl2: "https://unpkg.com/@rive-app/webgl2",
          canvas: "https://unpkg.com/@rive-app/canvas",
        },
      };

      // Wait for Rive global to be available after script load
      function waitForRiveGlobal() {
        return new Promise((resolve, reject) => {
          const start = Date.now();
          const timer = setInterval(() => {
            if (window.rive && typeof window.rive.Rive === 'function') {
              clearInterval(timer);
              resolve();
            } else if (Date.now() - start > 200) {
              clearInterval(timer);
              reject(new Error('Timed out waiting for Rive global'));
            }
          }, 200);
        });
      }

      // Toggles WebGL2 or Canvas runtime
      // if the desired runtime is different from the current, it unloads the existing runtime from <script> and loads the new one
      async function toggleRiveRuntime(desiredRuntime) {
        if (widgetState.runtime === desiredRuntime && window.rive) {
          return;
        }
        const existing = document.getElementById("rive-runtime-script");
        try {
          existing.remove();
          widgetState.r?.cleanup();
          delete window.rive;
        } catch {}
        const script = document.createElement("script");
        script.id = "rive-runtime-script";
        script.src = widgetState.runtimeSources[desiredRuntime];
        document.body.prepend(script);

        await new Promise((resolve, reject) => {
          script.onload = async () => {
            try {
              await waitForRiveGlobal();
              widgetState.runtime = desiredRuntime;
              resolve();
            } catch (e) {
              reject(e);
            }
          };
          script.onerror = () =>
            reject(new Error(`Failed to load ${desiredRuntime}`));
        });
      }

      // Resize canvas to fit window
      function resizeCanvas() {
        const canvas = document.getElementById("canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        widgetState.r?.resizeDrawingSurfaceToCanvas();
      }

      window.addEventListener("resize", resizeCanvas);
      
      // Displays FPS counter overlay (only if displayFpsCounter is true)
      function ensureFPSCounter(instance) {
        const overlay = document.getElementById("rive-fps-counter");
        if (widgetState.displayFpsCounter) {
          overlay.style.display = "block";

          instance.enableFPSCounter((fps) => {
            if (widgetState.displayFpsCounter) {
              overlay.textContent = `FPS: ${Math.round(fps)}`;
            }
          });
        } else {
          overlay.style.display = "none";
        }
      }

      // Get all view models and collect their properties (including nested VMs)
      function GetAllViewModelProperties(rive) {
        const props = {};
        const vmMetadata = {};
        const vmi = rive.viewModelInstance;
        const defaultVM = rive.defaultViewModel();
        const defaultVMName = defaultVM.name;
        const processedVMs = new Set();

        // Recursively process a view model and its properties
        function processViewModel(vm, pathPrefix = "") {
          if (processedVMs.has(vm)) return;
          processedVMs.add(vm);

          for (const property of vm.properties) {
            const propertyPath = pathPrefix
              ? `${pathPrefix}/${property.name}`
              : property.name;

            // Handle nested view models
            if (property.type === "viewModel") {
              let matchedVM = null;
              for (let i = 0; i < rive.viewModelCount; i++) {
                const nestedVM = rive.viewModelByIndex(i);
                if (!nestedVM || processedVMs.has(nestedVM)) continue;
                if (nestedVM.name && property.name.includes(nestedVM.name)) {
                  matchedVM = nestedVM;
                  break;
                }
              }

              if (matchedVM) {
                vmMetadata[property.name] = {
                  vmName: matchedVM.name,
                  parentProp: property.name,
                  parentVMName: vm.name,
                };
                processViewModel(matchedVM, property.name);
              }
              continue;
            }

            let accessor = null;
            try {
              switch (property.type) {
                case "string": accessor = vmi.string(propertyPath); break;
                case "number": accessor = vmi.number(propertyPath); break;
                case "boolean": accessor = vmi.boolean(propertyPath); break;
                case "trigger": accessor = vmi.trigger(propertyPath); break;
                case "color": accessor = vmi.color(propertyPath); break;
                case "image": accessor = vmi.image(propertyPath); break;
                case "enumType": accessor = vmi.enum(propertyPath); break;
                case "artboard": accessor = vmi.artboard(propertyPath); break;
              }
            } catch (err) {
              console.error("Error mapping: " + propertyPath + " " + err.message,);
            }

            if (accessor) {
              const propKey = propertyPath.replace(/\//g, "_");
              const propData = {
                type: property.type,
                accessor,
                path: propertyPath,
              };

              if (property.type === "enumType" && accessor.values) {
                propData.enumValues = accessor.values;
              }

              if (property.type === "artboard") {
                propData.artboardNames = [];
              }

              props[propKey] = propData;
            }
          }
        }

        processViewModel(defaultVM);

        return { props, vmMetadata, defaultVMName };
      }

      // Initialize Singular Widget
      SingularWidget.init({
        onInit: async (json) => {
          window.pendingInitialValues = json;

          const layoutIndex = parseInt(json.rive_layout, 10);

          widgetState.layoutFit = widgetState.layoutOptions?.[layoutIndex] || widgetState.layoutFit || "Contain";

          if (json.show_fps !== undefined) {
            widgetState.displayFpsCounter = json.show_fps;
          }

          const desiredRuntime = json.rive_renderer ? "webgl2" : "canvas";
          await toggleRiveRuntime(desiredRuntime);

          if ( typeof json.rive_file_url === "string" && json.rive_file_url.endsWith(".riv")) {
            widgetState.fileUrl = json.rive_file_url;
            initializeRive(json.rive_file_url);
          }
        },
        onValue: onSingularValue,
        onButtonClicked: onSingularButtonClicked,
      });

      // Initialize Rive with a given file URL
      function initializeRive(fileUrl) {
        const riveConfig = {
          src: fileUrl,
          canvas: document.getElementById("canvas"),
          autoplay: true,
          autoBind: true,
          ...(widgetState.runtime === "webgl2" ? { useOffscreenRenderer: true } : {}),
          layout: new rive.Layout({ fit: rive.Fit[widgetState.layoutFit] }),
          enableFPSCounter: true,
          
          onLoad: () => {
            resizeCanvas();

            const vmData = GetAllViewModelProperties(widgetState.r);
            widgetState.riveProps = vmData.props;
            window.vmMetadata = vmData.vmMetadata;
            window.defaultVMName = vmData.defaultVMName;
            generateUIModel();
            ensureFPSCounter(widgetState.r);
            
            // Apply pending initial values and clear them
            if (window.pendingInitialValues) {
            const initialValues = window.pendingInitialValues;
            window.pendingInitialValues = null;
            onSingularValue(initialValues);
            }
          },
          onLoadError: (err) => {
            console.error("[Rive Error] Rive load error:", err);
          },
        };
        
        riveConfig.artboard = widgetState.artboardName;
        riveConfig.stateMachines = widgetState.stateMachineName;

        widgetState.r = new rive.Rive(riveConfig);
      }
      
      // Generate alphanumeric ID from a string
      function toAlphanumericId(str) {
        return str.replace(/[^a-zA-Z0-9]/g, "");
      }

      // Convert Rive ARGB integer to Singular RGBA object
      function riveColorValueToRGBA(colorValue) {
        return {
          r: (colorValue >> 16) & 0xff,
          g: (colorValue >> 8) & 0xff,
          b: colorValue & 0xff,
          a: ((colorValue >> 24) & 0xff) / 255,
        };
      }

      // Generate Dynamic UI model for Singular Widget
      function generateUIModel() {        
        const fields = [];
        const groupedProperties = {};

        // Get available artboards from the Rive file
        const availableArtboards = [];
        const file = widgetState.r?.file;
        let currentArtboardIndex = 0;

        if (file) {
          // Get the default (active) artboard from Rive
          const defaultArtboard = file.defaultArtboard();
          const defaultArtboardName = defaultArtboard ? defaultArtboard.name : null;

          const artboardCount = file.artboardCount();
          for (let i = 0; i < artboardCount; i++) {
            const artboard = file.artboardByIndex(i);
            if (artboard) {
              const artboardName = artboard.name;
              availableArtboards.push(artboardName);

              // Check if this is the current artboard
              if (artboardName === widgetState.artboardName) {
                currentArtboardIndex = i;
              } else if (!widgetState.artboardName && artboardName === defaultArtboardName) {
                currentArtboardIndex = i;
              }
            }
          }
        }

        // Add artboard selection field
        if (availableArtboards.length > 0) {
          fields.push({
            id: "riveartboard",
            type: "selection",
            title: "Artboard",
            defaultValue: currentArtboardIndex.toString(),
            selections: availableArtboards.map((name, index) => ({
              id: index.toString(),
              title: name,
            })),
          });
        }

        // Add state machine selection field
        if (widgetState.r.stateMachineNames.length > 0) {
          const stateMachineOptions = widgetState.r.stateMachineNames;
          const currentStateMachineIndex = widgetState.stateMachineIndex || 0;

          fields.push({
            id: "rivestatemachineselect",
            type: "selection",
            title: "State Machine",
            defaultValue: currentStateMachineIndex.toString(),
            selections: stateMachineOptions.map((name, index) => ({
              id: index.toString(),
              title: name,
            })),
          });
        }

        // Track parent property info for nested view models
        const viewModelParentInfo = {};

        // for each property, create a UI field
        for (const [name, prop] of Object.entries(widgetState.riveProps)) {
          // if a property ends with __, skip it (a way to name properties like that to hide them from singular)
          if (name.includes("__")) continue;

          const displayName = name.includes("_") ? name.split("_").pop() : name;

          let viewModelName = window.defaultVMName || "Main";
          let parentPropertyName = null;

          // Check if this property belongs to a nested view model
          let groupKey = viewModelName; // Default to root VM name

          if (name.includes("_") && window.vmMetadata) {
            const parts = name.split("_");
            const pathPrefix = parts[0]; // e.g., "Propertyofscoreboard"

            // Look up the actual VM name from metadata
            if (window.vmMetadata[pathPrefix]) {
              viewModelName = window.vmMetadata[pathPrefix].vmName;
              parentPropertyName = window.vmMetadata[pathPrefix].parentProp;
              // Use parent property as grouping key to keep components separate
              groupKey = pathPrefix;
            } else {
              // Fallback for root properties with underscores
              parts.pop();
              viewModelName = parts.join(" ");
              groupKey = viewModelName;
            }
          }

          // Store metadata for each group
          if (!viewModelParentInfo[groupKey]) {
            viewModelParentInfo[groupKey] = {
              vmName: viewModelName,
              parentProp: parentPropertyName,
            };
          }

          let fieldType = prop.type;
          let defaultValue = "";
          let selections = undefined;

          switch (prop.type) {
            case "trigger": fieldType = "button"; break;
            case "string": fieldType = "text"; defaultValue = prop.accessor.value ?? ""; break;
            case "number": fieldType = "number"; defaultValue = prop.accessor.value ?? 0; break;
            case "boolean": fieldType = "checkbox"; defaultValue = prop.accessor.value ?? false; break;
            case "image": fieldType = "image"; defaultValue = ""; break;
            case "color": defaultValue = riveColorValueToRGBA(prop.accessor.value); break;
            case "enumType": { fieldType = "selection"; defaultValue = (prop.accessor.value ?? 0).toString();
              // Build selections from enumValues
              if (prop.enumValues?.length) {
                selections = prop.enumValues.map((v, i) => ({
                  id: i.toString(),
                  title: v,
                }));
              }
              break;
            }
            case "artboard": {
              fieldType = "selection";
              const currentArtboardName = prop.accessor.value;
              let selectedId = "0";
              // Build selections from available artboards, excluding the current displayed artboard
              if (availableArtboards.length > 0) {
                const filteredWithIndices = availableArtboards
                  .map((artboardName, originalIndex) => ({ artboardName, originalIndex }))
                  .filter(item => item.artboardName !== widgetState.artboardName);
                
                if (filteredWithIndices.length > 0) {
                  selections = filteredWithIndices.map((item) => {
                    if (item.artboardName === currentArtboardName) {
                      selectedId = item.originalIndex.toString();
                    }
                    return {
                      id: item.originalIndex.toString(),
                      title: item.artboardName,
                    };
                  });
                  defaultValue = selectedId;
                }
              }
              break;
            }
            default: console.warn(`Unknown property type: ${prop.type} for ${name}`);
          }

          // Use alphanumeric ID for dynamic fields
          const fieldId = toAlphanumericId(name);

          const field = {
            id: fieldId,
            type: fieldType,
            title: displayName,
            defaultValue: defaultValue,
          };

          // Add selections array for enum/selection fields
          if (selections) {
            field.selections = selections;
          }

          fields.push(field);

          if (!groupedProperties[groupKey]) {
            groupedProperties[groupKey] = [];
          }
          groupedProperties[groupKey].push(fieldId);
        }

        const groups = [];

        // Add artboard group at the top
        if (availableArtboards.length > 0) {
          const childIds = ["riveartboard"];

          // Add state machine field to the group if it exists
          if ( widgetState.r.stateMachineNames.length > 0) {
            childIds.push("rivestatemachineselect");
          }

          groups.push({
            id: "artboardgroup",
            title: "Artboard Selection",
            width: "double",
            toolTip: "Select the artboard to display",
            childIds: childIds,
          });
        }

        // Add other property groups
        for (const [groupKey, childIds] of Object.entries(groupedProperties)) {
          const groupInfo = viewModelParentInfo[groupKey];
          let groupTitle = groupKey;
          let vmName = groupKey;

          // Check if this is a nested view model group
          if (groupInfo && groupInfo.parentProp) {
            vmName = groupInfo.vmName;
            const parentProp = groupInfo.parentProp;
            const cleanParentProp = parentProp
              .replace(/[^a-zA-Z0-9]/g, "")
              .toLowerCase();

            // Look up metadata for this nested VM
            if (window.vmMetadata && window.vmMetadata[parentProp]) {
              const metadata = window.vmMetadata[parentProp];
              const parentVMName = metadata.parentVMName || "Main";
              groupTitle = `${parentVMName} (${cleanParentProp}: ${vmName})`;
            } else {
              groupTitle = `${vmName} - ${cleanParentProp}`;
            }
          } else if (groupInfo && groupInfo.vmName) {
            // Root VM group
            vmName = groupInfo.vmName;
            groupTitle = vmName;
          }

          groups.push({
            id: toAlphanumericId(groupKey) + "group",
            title: groupTitle,
            width: "double",
            toolTip: `Properties from ${vmName}`,
            childIds: childIds,
          });
        }

        // Set dynamic UI using SingularWidget.setCustomWidgetUI
        const uiModel = {
            fields: fields,
            groups: groups,
          };
          console.log(`Sending UI Model to Singular:`, JSON.stringify(uiModel, null, 2),);
          const res = SingularWidget.setCustomWidgetUI(uiModel);
          console.log(`Singular UI response:`, res);
      }

      // Handle singular value change
      // If a value such as Artboard/State Machine/File url/Renderer/Layout changes, reload the rive instance
      async function onSingularValue(json) {
        window.pendingInitialValues = window.pendingInitialValues ? { ...window.pendingInitialValues, ...json }: json;
        
        // Check for runtime change first and ensure it's loaded
        if (json.rive_renderer !== undefined) {
          const desiredRenderer = json.rive_renderer !== false;
          const desiredRuntime = desiredRenderer ? "webgl2" : "canvas";

          const runtimeChanged = widgetState.runtime && widgetState.runtime !== desiredRuntime;
          const needRuntimeLoad = !widgetState.runtime || runtimeChanged || !(window.rive);

          if (needRuntimeLoad) {
            try {
              await toggleRiveRuntime(desiredRuntime);
            } catch (e) {
              console.error("Failed to load desired runtime:", desiredRuntime ,e , );
              return;
            }
          }
        }

        // Handle file URL change - if it ends with .riv, load it immediately
        if (json.rive_file_url !== undefined) {
          if (
            typeof json.rive_file_url === "string" &&
            json.rive_file_url.endsWith(".riv")
          ) {
            const newFileUrl = json.rive_file_url;

            if (newFileUrl !== widgetState.fileUrl) {
              widgetState.fileUrl = newFileUrl;

              // Get layout if available
              let layoutFit = widgetState.layoutFit;
              if (json.rive_layout !== undefined) {
                layoutFit =
                  widgetState.layoutOptions[parseInt(json.rive_layout, 10)] ||
                  "Contain";
                widgetState.layoutFit = layoutFit;
              }

              // Reset artboard and state machine for new file
              widgetState.artboardName = "";
              widgetState.stateMachineName = "";
              widgetState.stateMachineIndex = 0;

              // If no instance yet, initialize; otherwise reload
              if (!widgetState.r) {
                initializeRive(newFileUrl);
              } else {
                reloadRive(newFileUrl);
              }
              return;
            }
          } else {
            return; // Don't process further if URL is invalid
          }
        }

        // If we don't have a Rive instance yet but we have a valid URL, initialize it
        if (
          !widgetState.r &&
          widgetState.fileUrl &&
          widgetState.fileUrl.endsWith(".riv")
        ) {
          initializeRive(widgetState.fileUrl);
          return;
        }

        // Handle show FPS change
        if (json.show_fps !== undefined) {
          widgetState.displayFpsCounter = json.show_fps === true;
          if (widgetState.r) {
            ensureFPSCounter(widgetState.r);
          }
        }

        // Handle layout change
        if (json.rive_layout !== undefined) {
          const newLayout =
            widgetState.layoutOptions[parseInt(json.rive_layout, 10)] ||
            "Contain";
          if (newLayout !== widgetState.layoutFit) {
            widgetState.layoutFit = newLayout;
            if (widgetState.r && widgetState.fileUrl) {
              reloadRive(widgetState.fileUrl);
              return;
            }
          }
        }

        // Handle dynamic artboard field (riveartboard) from dynamic UI
        if (json.riveartboard !== undefined && widgetState.r) {
          const artboardIndex = parseInt(json.riveartboard);
          const file = widgetState.r?.file;
          if (
            file &&
            artboardIndex >= 0 &&
            artboardIndex < file.artboardCount()
          ) {
            const artboard = file.artboardByIndex(artboardIndex);
            if (artboard) {
              const newArtboard =
                typeof artboard.name === "function"
                  ? artboard.name()
                  : artboard.name;
              if (newArtboard !== widgetState.artboardName) {
                widgetState.artboardName = newArtboard;

                // Reset state machine when artboard changes
                widgetState.stateMachineName = "";
                widgetState.stateMachineIndex = 0;

                if (widgetState.fileUrl) {
                  reloadRive(widgetState.fileUrl);
                  return;
                }
              }
            }
          }
        }

        // Handle state machine selection changes
        if (json.rivestatemachineselect !== undefined && widgetState.r) {
          const stateMachineIndex = parseInt(json.rivestatemachineselect);

          if (!isNaN(stateMachineIndex) && stateMachineIndex >= 0) {
            // Update tracked state machine index
            widgetState.stateMachineIndex = stateMachineIndex;

            // Get the state machine name by index
            let newStateMachineName = "";
            if (
              widgetState.r.stateMachineNames &&
              widgetState.r.stateMachineNames[stateMachineIndex]
            ) {
              newStateMachineName =
                widgetState.r.stateMachineNames[stateMachineIndex];
            }

            // Only reload if the state machine actually changed
            if (newStateMachineName !== widgetState.stateMachineName) {
              widgetState.stateMachineName = newStateMachineName;
              if (widgetState.fileUrl) {
                reloadRive(widgetState.fileUrl);
                return;
              }
            }
          }
        }

        // Don't process dynamic field updates if we don't have a valid Rive file loaded
        if (!widgetState.r) {
          return;
        }

        // Handle dynamic field updates - map alphanumeric IDs back to property names
        for (const [name, prop] of Object.entries(widgetState.riveProps)) {
          const alphanumericId = toAlphanumericId(name);
          if (json[alphanumericId] === undefined) continue;

          try {
            if (prop.type === "string" || prop.type === "number" || prop.type === "boolean") {
              const newValue = json[alphanumericId];
              if (newValue !== prop.accessor.value) {
                prop.accessor.value = newValue;
              }
            } 
             
            if (prop.type === "image") {
              let imageUrl = json[alphanumericId];

              if (!imageUrl || imageUrl === "") {
                continue;
              }

              // Handle protocol-relative URLs (//domain.com/...) and add https:// if needed
              if (imageUrl.startsWith("//")) {
                imageUrl = "https:" + imageUrl;
              } else if (
                !imageUrl.startsWith("http://") &&
                !imageUrl.startsWith("https://") &&
                !imageUrl.startsWith("data:")
              ) {
                imageUrl = "https://" + imageUrl;
              }

              // Check if this URL is different from the current one - skip if same
              if (prop.currentImageUrl === imageUrl) {
                continue;
              }

              // Store the new URL
              prop.currentImageUrl = imageUrl;

              // Fetch and decode the image
              (async () => {
                try {
                  const res = await fetch(imageUrl);
                  const { decodeImage } = window.rive;
                  const image = await decodeImage(
                    new Uint8Array(await res.arrayBuffer()),
                  );
                  prop.accessor.value = image;
                } catch (error) {
                  console.error(`Failed to load image ${name}:`, error);
                }
              })();

            }
            
            if (prop.type === "enumType") {
              // Handle enum selection updates - need to pass the enum value name, not the index
              const selectedIndex = parseInt(json[alphanumericId]);

              if (prop.enumValues[selectedIndex]) {
                const enumValueName = prop.enumValues[selectedIndex];
                const currentValue = prop.accessor.value;

                // Only update if the value has actually changed
                if (currentValue !== enumValueName) {
                  prop.accessor.value = enumValueName;
                }
              }
            }

            if (prop.type === "artboard") {
              const selectedIndex = parseInt(json[alphanumericId]);
              const file = widgetState.r?.file;

              if (file && selectedIndex >= 0 && selectedIndex < file.artboardCount()) {
                const artboardObj = file.artboardByIndex(selectedIndex);
                if (artboardObj && widgetState.fileUrl) {
                  const artboardName = artboardObj.name;
                  
                  // Create a RiveFile instance from the URL to get the proper artboard (a workaround for Rive runtime limitations)
                  // Update this when Rive docs support changing artboards directly
                  const riveFile = new rive.RiveFile({
                    src: widgetState.fileUrl,
                    onLoad: () => {
                      try {
                        const artboard = riveFile.getArtboard(artboardName);
                        if (artboard) {
                          prop.accessor.value = artboard;
                        }
                      } catch (err) {
                        console.error(`Failed to get artboard ${artboardName}:`, err);
                      }
                    }
                  });
                  riveFile.init();
                }
              }
            } 
            
            if (prop.type === "color") {
              const colorData = json[alphanumericId];
              let r, g, b, a;

              // Handle hex string format (from Uno Overlays)
              if (typeof colorData === "string" && colorData.startsWith("#")) {
                const hex = colorData.replace("#", "");
                r = parseInt(hex.substring(0, 2), 16);
                g = parseInt(hex.substring(2, 4), 16);
                b = parseInt(hex.substring(4, 6), 16);
                a = hex.length === 8 ? parseInt(hex.substring(6, 8), 16) : 255;
                prop.accessor.rgba(r, g, b, a);
              }
              // Handle object format (from Singular)
              else if (
                colorData &&
                typeof colorData === "object" &&
                "r" in colorData
              ) {
                r = Math.round(colorData.r);
                g = Math.round(colorData.g);
                b = Math.round(colorData.b);
                a =
                  colorData.a !== undefined
                    ? Math.round(colorData.a * 255)
                    : 255;
                prop.accessor.rgba(r, g, b, a);
              } else {
                console.warn(`Unknown color format for ${name}:`, colorData);
              }
            }
          } catch (err) {
            console.error(`Failed to update '${name}' (id: ${alphanumericId}):`,err.message,);
          }
        }
      }

      // Reload Rive instance with new parameters
      // Cleans up existing instance before re-initializing
      function reloadRive(fileUrl) {
        console.log("[reloadRive] Cleaning up and reloading...");
        
        if (widgetState.r) {
          try {
            widgetState.r.cleanup();
            console.log("[reloadRive] Cleanup successful");
          } catch (err) {
            console.warn("[reloadRive] Error cleaning up Rive:", err);
          }
          widgetState.r = null;
        }

        initializeRive(fileUrl);
      }

      // Handle button clicks from Singular Widget
      // Cycle through all rive properties to find matching trigger and trigger it
      function onSingularButtonClicked(action) {
        for (const [name, prop] of Object.entries(widgetState.riveProps)) {
          const alphanumericId = toAlphanumericId(name);
          if (alphanumericId === action && prop?.type === "trigger") {
            prop.accessor.trigger();
            return;
          }
        }
      }
    </script>
  </body>
</html>
