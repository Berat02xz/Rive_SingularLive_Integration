<!DOCTYPE html>
<html>
<head>
  <style>
    html, body { 
      background: none; 
      margin: 0; 
      padding: 0; 
      height: 100%; 
      width: 100%;
      overflow: hidden;
    }
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <script src="https://unpkg.com/@rive-app/webgl2"></script>
  <script src="https://unpkg.com/@rive-app/canvas"></script>

  <canvas id="canvas"></canvas>
  <script src="https://beta.singular.live/libs/singularwidget/1.0.4/singularwidget.js"></script>
  <script>
    let riveProps = {};
    let r = null;
    let ARTBOARD_NAME = "";
    const STATE_MACHINE_NAME = "State Machine 1";
    let LAYOUT_FIT = "contain";
    let USE_WEBGL2 = false;
    
    function resizeCanvas() {
      const canvas = document.getElementById("canvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (r) r.resizeDrawingSurfaceToCanvas();
    }
    window.addEventListener('resize', resizeCanvas);

    function getArtboardName(artboard) {
      return typeof artboard.name === 'function' ? artboard.name() : artboard.name;
    }

    // collect properties from a view model
    function collectProperties(vmi, viewModel, props, pathPrefix = "") {
      if (!viewModel.properties?.length) return;

      for (const property of viewModel.properties) {
        if (!property?.name || property.type === "viewModel") continue;
        
        const propertyPath = pathPrefix ? `${pathPrefix}/${property.name}` : property.name;
        let accessor = null;
        
        try {
          switch(property.type) {
            case "string":  accessor = vmi.string(propertyPath); break;
            case "number":  accessor = vmi.number(propertyPath); break;
            case "boolean": accessor = vmi.boolean(propertyPath); break;
            case "trigger": accessor = vmi.trigger(propertyPath); break;
            case "color":   accessor = vmi.color(propertyPath); break;
            case "enum":    accessor = vmi.enum(propertyPath); break;
          }
        } catch (err) {
          console.error(`Error accessing '${propertyPath}':`, err.message);
        }

        if (accessor) {
          // Make propKey alphanumeric: remove all non-alphanumeric characters (including spaces, /, _)
          const propKey = propertyPath.replace(/[^a-zA-Z0-9]/g, '');
          props[propKey] = { type: property.type, accessor, path: propertyPath };
        }
      }
    }

    // Get all view models and collect their properties
    function GetAllViewModelProperties(rive) {
      const props = {};
      const vmi = rive.viewModelInstance;
      const defaultVM = rive.defaultViewModel();
      
      if (!defaultVM) {
        console.error("No default view model");
        return props;
      }

      // collect properties from the default view model
      collectProperties(vmi, defaultVM, props, "");
      
      const processedVMs = new Set([defaultVM]);
      
      // Iterate over properties to find nested view models
      for (const prop of defaultVM.properties) {
        if (prop?.type === "viewModel" && prop.name) {
          let matchedVM = null;
          
          for (let i = 0; i < rive.viewModelCount; i++) {
            const vm = rive.viewModelByIndex(i);
            if (!vm || processedVMs.has(vm)) continue;
            if (vm.name && prop.name.includes(vm.name)) {
              matchedVM = vm;
              break;
            }
          }
          
          if (!matchedVM) {
            for (let i = 0; i < rive.viewModelCount; i++) {
              const vm = rive.viewModelByIndex(i);
              if (vm && !processedVMs.has(vm)) {
                matchedVM = vm;
                break;
              }
            }
          }
           
          if (matchedVM) {
            processedVMs.add(matchedVM);
            // collect properties from a nested view model
            collectProperties(vmi, matchedVM, props, prop.name);
          }
        }
      }
      
      return props;
    }
    
    // Initialize Rive
    const riveConfig = {
      src: "test_file.riv",
      canvas: document.getElementById("canvas"),
      autoplay: true,
      autoBind: true,
      stateMachines: STATE_MACHINE_NAME,
      onLoad: () => {
        console.log("âœ… Rive loaded successfully");
        resizeCanvas();
        
        if (r.viewModelCount === 0) return;

        riveProps = GetAllViewModelProperties(r);
        generateDynamicUI();
        
        if (window.pendingInitialValues) {
          console.log("Applying pending initial values:", window.pendingInitialValues);
          const initialValues = window.pendingInitialValues;
          window.pendingInitialValues = null;
          onSingularValue(initialValues);
        }
      },
    };
    
    if (ARTBOARD_NAME) riveConfig.artboard = ARTBOARD_NAME;
    if (!USE_WEBGL2) riveConfig.useOffscreenRenderer = false;
    r = new rive.Rive(riveConfig);

    // Generate dynamic UI for Singular Widget
    function generateDynamicUI() {
      const dynamicFields = [];
      const allPropertyIds = []; // Track all property IDs for single group
      
      // Get available artboards
      const availableArtboards = [];
      const file = r.file;
      if (file) {
        const artboardCount = file.artboardCount();
        for (let i = 0; i < artboardCount; i++) {
          const artboard = file.artboardByIndex(i);
          if (artboard) availableArtboards.push(getArtboardName(artboard));
        }
      }
      
      // Add dynamic artboard selector field
      dynamicFields.push({
        id: "dynamicartboard",
        type: "selection",
        title: "Artboard",
        defaultValue: "0",
        selections: availableArtboards.map((name, index) => ({
          id: index.toString(),
          title: name
        }))
      });
      
      // Build dynamic fields for view model properties
      for (const [name, prop] of Object.entries(riveProps)) {
        // Use the original path to determine view model and property name
        const originalPath = prop.path;
        
        // Get the display name (last part of the path)
        const pathParts = originalPath.split('/');
        const displayName = pathParts[pathParts.length - 1];
        
        // Skip properties that start with underscore
        if (displayName.startsWith('_')) {
          console.log(`Skipping property: ${displayName} (starts with _)`);
          continue;
        }
        
        let fieldType = prop.type;
        let defaultValue = "";
        
        if (prop.type === "trigger") {
          fieldType = "button";
        } else if (prop.type === "string") {
          fieldType = "text";
          defaultValue = prop.accessor.value || "";
        } else if (prop.type === "number") {
          defaultValue = prop.accessor.value || 0;
        } else if (prop.type === "boolean") {
          fieldType = "checkbox";
          defaultValue = prop.accessor.value || false;
        } else if (prop.type === "color") {
          const colorValue = prop.accessor.value;
          defaultValue = {
            r: (colorValue >> 16) & 0xFF,
            g: (colorValue >> 8) & 0xFF,
            b: colorValue & 0xFF,
            a: ((colorValue >> 24) & 0xFF) / 255
          };
        }
        
        dynamicFields.push({
          id: name,
          type: fieldType,
          title: displayName.charAt(0).toUpperCase() + displayName.slice(1),
          defaultValue: defaultValue
        });
        
        // Add to single group tracking
        allPropertyIds.push(name);
      }

      // Build dynamic groups - use only 2 static groups
      const dynamicGroups = [];
      
      // Add artboard configuration group at the top
      dynamicGroups.push({
        id: "dynamicartboardgroup",
        title: "Artboard Selection",
        width: "double",
        toolTip: "Select which artboard to display",
        childIds: ["dynamicartboard"]
      });
      
      // Add single group for all Rive properties
      if (allPropertyIds.length > 0) {
        dynamicGroups.push({
          id: "rivepropertiesgroup",
          title: "Rive Properties",
          width: "double",
          toolTip: "All properties from Rive view models",
          childIds: allPropertyIds
        });
      }

      // Clear previous dynamic UI first by sending empty arrays
      console.log("\nðŸ§¹ Clearing previous dynamic UI...");
      SingularWidget.setCustomWidgetUI({ fields: [], groups: [] }, (clearResponse) => {
        console.log("Clear response:", clearResponse);
      });
      
      // Now send the new dynamic UI
      const dynamicUI = {
        fields: dynamicFields,
        groups: dynamicGroups
      };
      
      console.log("ðŸ“¤ Setting new dynamic UI with", dynamicFields.length, "fields and", dynamicGroups.length, "groups");
      console.log("Field IDs:", dynamicFields.map(f => f.id));
      console.log("Group IDs:", dynamicGroups.map(g => g.id));
      
      SingularWidget.setCustomWidgetUI(dynamicUI, (response) => {
        console.log("âœ… Dynamic UI response:", response);
        if (response.success) {
          console.log("âœ… Dynamic UI successfully set!");
        } else {
          console.error("âŒ Failed to set dynamic UI:", response);
        }
      });

      // Clear previous dynamic UI first by sending empty arrays
      console.log("\nðŸ§¹Clearing again just to test...");
      SingularWidget.setCustomWidgetUI({ fields: [], groups: [] }, (clearResponse) => {
        console.log("Clear response:", clearResponse);
      });
    }

    // Initialize Singular Widget
    SingularWidget.init({
      onInit: (json) => {
        window.pendingInitialValues = json;
      },
      onValue: onSingularValue,
      onButtonClicked: onSingularButtonClicked,
    });

    // Handle singular value change
    // if a value such as artboard or layout changes, then it reloads Rive (required)
    function onSingularValue(json) {
      window.pendingInitialValues = window.pendingInitialValues 
        ? { ...window.pendingInitialValues, ...json } 
        : json;
      
      let needsReload = false;
      let newArtboard = ARTBOARD_NAME;
      let newLayout = LAYOUT_FIT;
      let newFileUrl = r?.src || "test_file.riv";
      let newRenderer = USE_WEBGL2;
      
      // Handle dynamic artboard change (from dynamic UI)
      if (json.dynamicartboard !== undefined) {
        const artboardIndex = parseInt(json.dynamicartboard);
        const file = r.file;
        if (file && artboardIndex >= 0 && artboardIndex < file.artboardCount()) {
          const artboard = file.artboardByIndex(artboardIndex);
          if (artboard) newArtboard = getArtboardName(artboard);
        }
        if (newArtboard !== ARTBOARD_NAME) {
          ARTBOARD_NAME = newArtboard;
          needsReload = true;
        }
      }
      
      // Handle static artboard change (from Widget Manager UI)
      if (json.rive_artboard !== undefined) {
        const artboardIndex = parseInt(json.rive_artboard);
        const file = r.file;
        if (file && artboardIndex >= 0 && artboardIndex < file.artboardCount()) {
          const artboard = file.artboardByIndex(artboardIndex);
          if (artboard) newArtboard = getArtboardName(artboard);
        }
        if (newArtboard !== ARTBOARD_NAME) {
          ARTBOARD_NAME = newArtboard;
          needsReload = true;
        }
      }
      
      if (json.rive_layout !== undefined) {
        const layoutOptions = ["contain", "cover", "fill", "fitWidth", "fitHeight", "scaleDown", "layout", "none"];
        newLayout = layoutOptions[parseInt(json.rive_layout)] || "contain";
        if (newLayout !== LAYOUT_FIT) {
          LAYOUT_FIT = newLayout;
          needsReload = true;
        }
      }
      
      if (json.rive_file_url !== undefined && json.rive_file_url !== newFileUrl) {
        newFileUrl = json.rive_file_url;
        needsReload = true;
      }
      
      if (json.rive_renderer !== undefined && json.rive_renderer !== newRenderer) {
        newRenderer = json.rive_renderer;
        needsReload = true;
      }
      
      if (needsReload) {
        console.log("Reloading Rive with new configuration:", {
          fileUrl: newFileUrl,
          artboard: newArtboard,
          layout: newLayout,
          useWebGL2: newRenderer
        });
        window.pendingInitialValues = json;
        reloadRive(newFileUrl, newArtboard, newLayout, newRenderer);
        return;
      }

      for (const [name, prop] of Object.entries(riveProps)) {
        if (json[name] === undefined) continue;

        try {
          if (prop.type === "string" || prop.type === "number" || prop.type === "boolean") {
            const newValue = json[name];
            if (newValue !== prop.accessor.value) {
              prop.accessor.value = newValue;
            }
          } else if (prop.type === "color") {
            const colorData = json[name];
            if (colorData && typeof colorData === 'object' && 'r' in colorData) {
              const r = Math.round(colorData.r);
              const g = Math.round(colorData.g);
              const b = Math.round(colorData.b);
              const a = colorData.a !== undefined ? Math.round(colorData.a * 255) : 255;
              prop.accessor.rgba(r, g, b, a);
            }
          }
        } catch (err) {
          console.error(`Failed to update '${name}':`, err.message);
        }
      }
    }
    
    function reloadRive(fileUrl, artboardName, layoutFit, useWebGL2) {
      if (r) {
        try {
          r.cleanup();
        } catch (err) {
          console.warn("Error cleaning up Rive:", err);
        }
      }
      
      USE_WEBGL2 = useWebGL2;
      
      const riveConfig = {
        src: fileUrl,
        canvas: document.getElementById("canvas"),
        autoplay: true,
        autoBind: true,
        stateMachines: STATE_MACHINE_NAME,
        layout: new rive.Layout({
          fit: rive.Fit[layoutFit.charAt(0).toUpperCase() + layoutFit.slice(1)] || rive.Fit.Contain
        }),
        onLoad: () => {
          resizeCanvas();
          
          if (r.viewModelCount === 0) return;

          riveProps = GetAllViewModelProperties(r);
          generateDynamicUI();
            
          if (window.pendingInitialValues) {
            console.log("Applying pending initial values after reload:", window.pendingInitialValues);
            const initialValues = window.pendingInitialValues;
            window.pendingInitialValues = null;
            onSingularValue(initialValues);
          }
        },
        onLoadError: (err) => console.error("Rive reload error:", err)
      };
      
      if (artboardName) riveConfig.artboard = artboardName;
      if (!useWebGL2) riveConfig.useOffscreenRenderer = false;
      
      r = new rive.Rive(riveConfig);
    }

    // Handle button clicks from Singular Widget
    function onSingularButtonClicked(action) {
      const prop = riveProps[action];
      if (prop?.type === "trigger" && typeof prop.accessor.trigger === "function") {
        prop.accessor.trigger();
      }
    }
    
  </script>
</body>
</html>
