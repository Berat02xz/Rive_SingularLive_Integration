<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RiveLink Widget</title>
  <style>
    html, body {
      background: none;
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
    }
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- Singular Widget SDK -->
  <script src="https://beta.singular.live/libs/singularwidget/1.0.4/singularwidget.js"></script>
  
  <script>
    // ============================================================
    // RiveLink Widget - Bundled Version
    // ============================================================

    // -------------------- UTILS --------------------
    function parseBool(value, defaultVal = true) {
        if (value === undefined || value === null) return defaultVal;
        if (typeof value === 'boolean') return value;
        if (typeof value === 'number') return value !== 0;
        if (typeof value === 'string') {
            const v = value.trim().toLowerCase();
            if (['true', '1', 'on', 'yes'].includes(v)) return true;
            if (['false', '0', 'off', 'no'].includes(v)) return false;
            return defaultVal;
        }
        return !!value;
    }

    function toAlphanumericId(str) {
        return str.replace(/[^a-zA-Z0-9]/g, '');
    }

    function getArtboardName(artboard) {
        return typeof artboard.name === 'function' ? artboard.name() : artboard.name;
    }

    function getName(obj) {
        return typeof obj?.name === 'function' ? obj.name() : obj?.name || '';
    }

    function capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function hexToRgba(hex) {
        const cleanHex = hex.replace('#', '');
        return {
            r: parseInt(cleanHex.substring(0, 2), 16),
            g: parseInt(cleanHex.substring(2, 4), 16),
            b: parseInt(cleanHex.substring(4, 6), 16),
            a: cleanHex.length === 8 ? parseInt(cleanHex.substring(6, 8), 16) : 255
        };
    }

    function normalizeColorObject(colorData) {
        return {
            r: Math.round(colorData.r),
            g: Math.round(colorData.g),
            b: Math.round(colorData.b),
            a: colorData.a !== undefined ? Math.round(colorData.a * 255) : 255
        };
    }

    const LAYOUT_OPTIONS = ['contain', 'cover', 'fill', 'fitWidth', 'fitHeight', 'scaleDown', 'layout', 'none'];
    
    function getLayoutFit(index) {
        return LAYOUT_OPTIONS[parseInt(index)] || 'contain';
    }

    // -------------------- RUNTIME MANAGER --------------------
    const RUNTIME_SOURCES = {
        webgl2: 'https://unpkg.com/@rive-app/webgl2',
        canvas: 'https://unpkg.com/@rive-app/canvas'
    };
    const RUNTIME_SCRIPT_ID = 'rive-runtime-script';
    let currentRuntime = null;

    function waitForRiveGlobal() {
        return new Promise((resolve, reject) => {
            const start = Date.now();
            const timer = setInterval(() => {
                if (window.rive && typeof window.rive.Rive === 'function') {
                    clearInterval(timer);
                    resolve();
                } else if (Date.now() - start > 4000) {
                    clearInterval(timer);
                    reject(new Error('Timed out waiting for Rive global'));
                }
            }, 50);
        });
    }

    async function ensureRiveRuntime(runtimeType) {
        console.log('ðŸ”Œ [ensureRiveRuntime] Requested:', runtimeType, '| Current:', currentRuntime);
        
        if (currentRuntime === runtimeType && window.rive?.Rive) {
            console.log('ðŸ”Œ [ensureRiveRuntime] Already loaded, skipping');
            return;
        }

        const existing = document.getElementById(RUNTIME_SCRIPT_ID);
        if (existing) {
            console.log('ðŸ”Œ [ensureRiveRuntime] Removing existing script');
            existing.remove();
        }

        try { delete window.rive; } catch {}

        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.id = RUNTIME_SCRIPT_ID;
            script.src = RUNTIME_SOURCES[runtimeType];
            
            script.onload = async () => {
                try {
                    await waitForRiveGlobal();
                    currentRuntime = runtimeType;
                    console.log('ðŸ”Œ [ensureRiveRuntime] Loaded successfully:', runtimeType);
                    resolve();
                } catch (e) {
                    reject(e);
                }
            };
            
            script.onerror = () => reject(new Error(`Failed to load Rive runtime: ${runtimeType}`));
            document.body.prepend(script);
        });
    }

    function getCurrentRuntime() {
        return currentRuntime;
    }

    function isWebGL2() {
        return currentRuntime === 'webgl2';
    }

    // -------------------- VIEW MODEL --------------------
    const PROPERTY_TYPES = {
        STRING: 'string', NUMBER: 'number', BOOLEAN: 'boolean',
        TRIGGER: 'trigger', COLOR: 'color', ENUM: 'enumType', VIEW_MODEL: 'viewModel'
    };

    function getPropertyAccessor(vmi, path, type) {
        try {
            switch (type) {
                case PROPERTY_TYPES.STRING: return vmi.string(path);
                case PROPERTY_TYPES.NUMBER: return vmi.number(path);
                case PROPERTY_TYPES.BOOLEAN: return vmi.boolean(path);
                case PROPERTY_TYPES.TRIGGER: return vmi.trigger(path);
                case PROPERTY_TYPES.COLOR: return vmi.color(path);
                case PROPERTY_TYPES.ENUM: return vmi.enum(path);
                default: return null;
            }
        } catch { return null; }
    }

    function extractEnumValues(accessor) {
        const methods = ['values', 'enumValues', 'options'];
        for (const method of methods) {
            const val = typeof accessor[method] === 'function' ? accessor[method]() : accessor[method];
            if (val && (Array.isArray(val) || val.length > 0)) {
                return Array.isArray(val) ? val : Array.from(val);
            }
        }
        return null;
    }

    function collectProperties(vmi, viewModel, props, pathPrefix = '') {
        if (!viewModel.properties?.length) return;
        for (const property of viewModel.properties) {
            if (!property?.name || property.type === PROPERTY_TYPES.VIEW_MODEL) continue;
            const propertyPath = pathPrefix ? `${pathPrefix}/${property.name}` : property.name;
            const accessor = getPropertyAccessor(vmi, propertyPath, property.type);
            if (!accessor) continue;
            const propKey = propertyPath.replace(/\//g, '_');
            const propData = { type: property.type, accessor, path: propertyPath };
            if (property.type === PROPERTY_TYPES.ENUM) {
                const enumValues = extractEnumValues(accessor);
                if (enumValues) propData.enumValues = enumValues;
            }
            props[propKey] = propData;
        }
    }

    function getAllViewModelProperties(riveInstance) {
        console.log('ðŸ“‹ [getAllViewModelProperties] Extracting view model properties...');
        const props = {};
        const vmMetadata = {};
        const vmi = riveInstance.viewModelInstance;
        const defaultVM = riveInstance.defaultViewModel();

        if (!defaultVM) {
            console.log('ðŸ“‹ [getAllViewModelProperties] No default view model found');
            return { props, vmMetadata, defaultVMName: 'Main' };
        }

        const defaultVMName = getName(defaultVM);
        console.log('ðŸ“‹ [getAllViewModelProperties] Default VM:', defaultVMName);
        
        collectProperties(vmi, defaultVM, props, '');
        const processedVMs = new Set([defaultVM]);

        for (const prop of defaultVM.properties) {
            if (prop?.type !== PROPERTY_TYPES.VIEW_MODEL || !prop.name) continue;
            let matchedVM = null;
            for (let i = 0; i < riveInstance.viewModelCount; i++) {
                const vm = riveInstance.viewModelByIndex(i);
                if (!vm || processedVMs.has(vm)) continue;
                if (vm.name && prop.name.includes(vm.name)) { matchedVM = vm; break; }
            }
            if (!matchedVM) {
                for (let i = 0; i < riveInstance.viewModelCount; i++) {
                    const vm = riveInstance.viewModelByIndex(i);
                    if (vm && !processedVMs.has(vm)) { matchedVM = vm; break; }
                }
            }
            if (matchedVM) {
                processedVMs.add(matchedVM);
                const vmName = getName(matchedVM);
                vmMetadata[prop.name] = { vmName, parentProp: prop.name, parentVMName: defaultVMName };
                collectProperties(vmi, matchedVM, props, prop.name);
            }
        }

        console.log('ðŸ“‹ [getAllViewModelProperties] Found', Object.keys(props).length, 'properties');
        return { props, vmMetadata, defaultVMName };
    }

    // -------------------- UI GENERATOR --------------------
    function mapFieldType(riveType) {
        const typeMap = { trigger: 'button', string: 'text', boolean: 'checkbox', enumType: 'selection' };
        return typeMap[riveType] || riveType;
    }

    function getDefaultValue(prop) {
        const { type, accessor } = prop;
        switch (type) {
            case 'string': return accessor.value || '';
            case 'number': return accessor.value || 0;
            case 'boolean': return accessor.value || false;
            case 'enumType': return String(accessor.value || 0);
            case 'color': {
                const c = accessor.value;
                return { r: (c >> 16) & 0xFF, g: (c >> 8) & 0xFF, b: c & 0xFF, a: ((c >> 24) & 0xFF) / 255 };
            }
            default: return '';
        }
    }

    function buildEnumSelections(prop) {
        if (!prop.enumValues?.length) return [{ id: '0', title: 'Option 0' }];
        return prop.enumValues.map((val, idx) => ({ id: String(idx), title: val }));
    }

    function getArtboards(riveInstance, currentArtboard) {
        const artboards = [];
        let currentIndex = 0;
        const file = riveInstance?.file;
        if (!file) return { artboards, currentIndex };
        const count = file.artboardCount();
        for (let i = 0; i < count; i++) {
            const artboard = file.artboardByIndex(i);
            if (!artboard) continue;
            const name = getArtboardName(artboard);
            artboards.push(name);
            if (currentArtboard && name === currentArtboard) currentIndex = i;
        }
        return { artboards, currentIndex };
    }

    function generateUIModel(riveInstance, riveProps, vmMetadata, defaultVMName, currentArtboard) {
        console.log('ðŸŽ¨ [generateUIModel] Generating UI...');
        const fields = [];
        const groups = [];
        const groupedProperties = {};
        const viewModelParentInfo = {};

        const { artboards, currentIndex } = getArtboards(riveInstance, currentArtboard);
        console.log('ðŸŽ¨ [generateUIModel] Artboards:', artboards, '| Current index:', currentIndex);
        
        // Get available state machines
        const stateMachines = state.availableStateMachines || [];
        const currentSMIndex = stateMachines.indexOf(state.stateMachineName);
        console.log('ðŸŽ¨ [generateUIModel] State Machines:', stateMachines, '| Current:', state.stateMachineName, '| Index:', currentSMIndex);
        
        const artboardGroupChildIds = [];
        
        if (artboards.length > 0) {
            fields.push({
                id: 'riveartboard', type: 'selection', title: 'Artboard',
                defaultValue: String(currentIndex),
                selections: artboards.map((name, idx) => ({ id: String(idx), title: name }))
            });
            artboardGroupChildIds.push('riveartboard');
        }
        
        // Add state machine selection
        if (stateMachines.length > 0) {
            fields.push({
                id: 'rivestatemachine', type: 'selection', title: 'State Machine',
                defaultValue: String(Math.max(0, currentSMIndex)),
                selections: stateMachines.map((name, idx) => ({ id: String(idx), title: name }))
            });
            artboardGroupChildIds.push('rivestatemachine');
        }
        
        if (artboardGroupChildIds.length > 0) {
            groups.push({
                id: 'artboardgroup', title: 'Artboard & State Machine', width: 'double',
                toolTip: 'Select the artboard and state machine', childIds: artboardGroupChildIds
            });
        }

        for (const [name, prop] of Object.entries(riveProps)) {
            if (name.includes('__')) continue;
            const displayName = name.includes('_') ? name.split('_').pop() : name;
            const fieldId = toAlphanumericId(name);
            
            let groupKey = defaultVMName;
            if (name.includes('_') && vmMetadata) {
                const pathPrefix = name.split('_')[0];
                if (vmMetadata[pathPrefix]) {
                    groupKey = pathPrefix;
                    if (!viewModelParentInfo[pathPrefix]) {
                        viewModelParentInfo[pathPrefix] = { vmName: vmMetadata[pathPrefix].vmName, parentProp: vmMetadata[pathPrefix].parentProp };
                    }
                }
            }
            if (!viewModelParentInfo[groupKey]) {
                viewModelParentInfo[groupKey] = { vmName: groupKey, parentProp: null };
            }

            const field = { id: fieldId, type: mapFieldType(prop.type), title: displayName, defaultValue: getDefaultValue(prop) };
            if (prop.type === 'enumType') field.selections = buildEnumSelections(prop);
            fields.push(field);
            if (!groupedProperties[groupKey]) groupedProperties[groupKey] = [];
            groupedProperties[groupKey].push(fieldId);
        }

        for (const [groupKey, childIds] of Object.entries(groupedProperties)) {
            const groupInfo = viewModelParentInfo[groupKey];
            let groupTitle = groupInfo?.vmName || groupKey;
            if (groupInfo?.parentProp && vmMetadata?.[groupInfo.parentProp]?.parentVMName) {
                const cleanProp = toAlphanumericId(groupInfo.parentProp).toLowerCase();
                groupTitle = `${vmMetadata[groupInfo.parentProp].parentVMName} (${cleanProp}: ${groupInfo.vmName})`;
            }
            groups.push({
                id: toAlphanumericId(groupKey) + 'group', title: groupTitle, width: 'double',
                toolTip: `Properties from ${groupInfo?.vmName || groupKey}`, childIds
            });
        }

        const uiModel = { fields, groups };
        console.log('ðŸŽ¨ [generateUIModel] UI Model:', JSON.stringify(uiModel, null, 2));
        return uiModel;
    }

    function sendUIToSingular(uiModel) {
        if (typeof SingularWidget?.setCustomWidgetUI !== 'function') {
            console.error('âŒ SingularWidget.setCustomWidgetUI not available');
            return false;
        }
        console.log('ðŸ“¤ [sendUIToSingular] Sending UI to Singular...');
        const result = SingularWidget.setCustomWidgetUI(uiModel);
        console.log('ðŸ“¤ [sendUIToSingular] Result:', result);
        return result?.success !== false;
    }

    // -------------------- RIVE CONTROLLER --------------------
    const USE_OFFSCREEN_RENDERER = true;

    function resizeCanvas(riveInstance) {
        const canvas = document.getElementById('canvas');
        if (!canvas) return;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if (riveInstance) riveInstance.resizeDrawingSurfaceToCanvas();
    }

    function createLayout(layoutFit) {
        if (!window.rive?.Layout) return undefined;
        const fitKey = capitalize(layoutFit);
        const fit = rive.Fit[fitKey] || rive.Fit.Contain;
        return new rive.Layout({ fit });
    }

    function buildRiveConfig(options) {
        const { fileUrl, artboardName, stateMachineName, layoutFit, onLoad, onError } = options;
        
        console.log('ðŸ”§ [buildRiveConfig] Building config:');
        console.log('   - artboardName:', artboardName || '(default)');
        console.log('   - stateMachineName:', stateMachineName || '(auto-detect)');
        console.log('   - layoutFit:', layoutFit);
        
        const config = {
            src: fileUrl,
            canvas: document.getElementById('canvas'),
            autoplay: true,
            autoBind: true,
            layout: createLayout(layoutFit),
            onLoad,
            onLoadError: onError
        };

        if (isWebGL2()) config.useOffscreenRenderer = USE_OFFSCREEN_RENDERER;
        if (artboardName) config.artboard = artboardName;
        if (stateMachineName) {
            console.log('ðŸ”§ [buildRiveConfig] Adding stateMachines:', stateMachineName);
            config.stateMachines = stateMachineName;
        } else {
            console.log('ðŸ”§ [buildRiveConfig] No stateMachine - Rive will auto-detect');
        }

        return config;
    }

    function createRiveInstance(options) {
        console.log('ðŸš€ [createRiveInstance] Creating new Rive instance...');
        const config = buildRiveConfig(options);
        return new rive.Rive(config);
    }

    function cleanupRive(riveInstance) {
        if (!riveInstance) {
            console.log('ðŸ§¹ [cleanupRive] No instance to cleanup');
            return;
        }
        console.log('ðŸ§¹ [cleanupRive] Cleaning up Rive instance...');
        try {
            riveInstance.cleanup();
            console.log('ðŸ§¹ [cleanupRive] Cleanup successful');
        } catch (e) {
            console.log('ðŸ§¹ [cleanupRive] Cleanup error:', e.message);
        }
    }

    function getStateMachineName(riveInstance) {
        console.log('ðŸ” [getStateMachineName] Available:', riveInstance?.stateMachineNames);
        if (riveInstance?.stateMachineNames?.length > 0) {
            const name = riveInstance.stateMachineNames[0];
            console.log('ðŸ” [getStateMachineName] Using:', name);
            return name;
        }
        console.log('ðŸ” [getStateMachineName] None found');
        return '';
    }

    function hasViewModels(riveInstance) {
        return riveInstance?.viewModelCount > 0;
    }

    // -------------------- APP STATE --------------------
    const state = {
        riveInstance: null,
        riveProps: {},
        vmMetadata: {},
        defaultVMName: 'Main',
        artboardName: '',
        stateMachineName: '',
        availableStateMachines: [],
        layoutFit: 'contain',
        fileUrl: '',
        initialized: false,
        hasInitialValues: false,
        pendingValues: null
    };

    // -------------------- APP FUNCTIONS --------------------
    function onRiveLoad() {
        console.log('\nâœ… ========== RIVE LOADED ==========');
        console.log('âœ… state.artboardName:', state.artboardName);
        console.log('âœ… state.stateMachineName (before detect):', state.stateMachineName);
        
        resizeCanvas(state.riveInstance);
        
        // Store all available state machines
        state.availableStateMachines = state.riveInstance?.stateMachineNames || [];
        console.log('âœ… Available state machines:', state.availableStateMachines);
        
        // If no state machine selected yet, auto-detect first one
        if (!state.stateMachineName && state.availableStateMachines.length > 0) {
            state.stateMachineName = state.availableStateMachines[0];
            console.log('âœ… Auto-selected state machine:', state.stateMachineName);
        }
        
        // Play the selected state machine
        if (state.stateMachineName && state.riveInstance) {
            try {
                console.log('âœ… Playing state machine:', state.stateMachineName);
                state.riveInstance.play(state.stateMachineName);
            } catch (e) {
                console.log('âœ… Play error:', e.message);
            }
        }

        if (hasViewModels(state.riveInstance)) {
            const vmData = getAllViewModelProperties(state.riveInstance);
            state.riveProps = vmData.props;
            state.vmMetadata = vmData.vmMetadata;
            state.defaultVMName = vmData.defaultVMName;
        } else {
            state.riveProps = {};
        }

        updateUI();

        if (state.pendingValues) {
            console.log('âœ… Applying pending values...');
            const pending = state.pendingValues;
            state.pendingValues = null;
            handleValueChange(pending);
        }
        console.log('âœ… ===================================\n');
    }

    function onRiveError(err) {
        console.error('âŒ Rive load error:', err);
        updateUI();
    }

    function loadRive(fileUrl, useStateMachine = '') {
        console.log('\nðŸ“¦ ========== LOADING RIVE ==========');
        console.log('ðŸ“¦ File:', fileUrl);
        console.log('ðŸ“¦ state.artboardName:', state.artboardName);
        console.log('ðŸ“¦ state.stateMachineName:', state.stateMachineName);
        console.log('ðŸ“¦ useStateMachine param:', useStateMachine);
        
        cleanupRive(state.riveInstance);
        state.riveInstance = null;
        state.riveProps = {};
        
        // Use provided state machine or empty (let onRiveLoad auto-detect)
        const smToUse = useStateMachine || '';
        console.log('ðŸ“¦ Creating instance with stateMachineName:', smToUse || '(empty - will auto-detect)');
        
        state.riveInstance = createRiveInstance({
            fileUrl,
            artboardName: state.artboardName,
            stateMachineName: smToUse,
            layoutFit: state.layoutFit,
            onLoad: onRiveLoad,
            onError: onRiveError
        });
        
        state.initialized = true;
        console.log('ðŸ“¦ =====================================\n');
    }

    function updateUI() {
        const uiModel = generateUIModel(
            state.riveInstance, state.riveProps, state.vmMetadata,
            state.defaultVMName, state.artboardName
        );
        sendUIToSingular(uiModel);
    }

    function updateProperty(name, prop, value) {
        try {
            switch (prop.type) {
                case 'string':
                case 'number':
                case 'boolean':
                    if (value !== prop.accessor.value) {
                        prop.accessor.value = value;
                    }
                    break;
                case 'enumType': {
                    const index = parseInt(value);
                    if (!isNaN(index) && prop.enumValues?.[index]) {
                        const enumValue = prop.enumValues[index];
                        if (prop.accessor.value !== enumValue) {
                            prop.accessor.value = enumValue;
                        }
                    }
                    break;
                }
                case 'color': {
                    let rgba;
                    if (typeof value === 'string' && value.startsWith('#')) {
                        rgba = hexToRgba(value);
                    } else if (value && typeof value === 'object' && 'r' in value) {
                        rgba = normalizeColorObject(value);
                    } else {
                        return;
                    }
                    prop.accessor.rgba(rgba.r, rgba.g, rgba.b, rgba.a);
                    break;
                }
            }
        } catch (err) {
            console.error('âŒ [updateProperty] Failed:', name, err.message);
        }
    }

    async function handleValueChange(json) {
        console.log('\nðŸ“¥ [handleValueChange] Received:', Object.keys(json));
        
        state.pendingValues = state.pendingValues ? { ...state.pendingValues, ...json } : json;

        // Handle runtime change
        if (json.rive_renderer !== undefined) {
            console.log('\nðŸŽ® ========== RENDERER CHANGE ==========');
            const useWebGL2 = parseBool(json.rive_renderer, true);
            const desiredRuntime = useWebGL2 ? 'webgl2' : 'canvas';
            console.log('ðŸŽ® Desired:', desiredRuntime, '| Current:', getCurrentRuntime());
            
            state.hasInitialValues = true;
            const curRuntime = getCurrentRuntime();
            const needsSwitch = !curRuntime || curRuntime !== desiredRuntime;
            console.log('ðŸŽ® Needs switch:', needsSwitch);

            if (needsSwitch) {
                if (curRuntime && state.riveInstance) {
                    console.log('ðŸŽ® Cleaning up before switch...');
                    cleanupRive(state.riveInstance);
                    state.riveInstance = null;
                }
                try {
                    await ensureRiveRuntime(desiredRuntime);
                } catch (e) {
                    console.error('ðŸŽ® Failed to load runtime:', e);
                    return;
                }
            }
            console.log('ðŸŽ® ========================================\n');
        }

        // Handle file URL change
        if (json.rive_file_url !== undefined) {
            const newUrl = json.rive_file_url;
            if (typeof newUrl === 'string' && newUrl.endsWith('.riv') && newUrl !== state.fileUrl) {
                console.log('ðŸ“ File URL changed:', newUrl);
                state.fileUrl = newUrl;
                if (json.rive_layout !== undefined) state.layoutFit = getLayoutFit(json.rive_layout);
                state.artboardName = '';
                state.stateMachineName = '';
                loadRive(newUrl);
                return;
            }
            if (!newUrl?.endsWith?.('.riv')) return;
        }

        // Initialize if needed
        if (!state.riveInstance && state.fileUrl) {
            console.log('ðŸ“ No instance, loading...');
            loadRive(state.fileUrl);
            return;
        }

        // Handle layout change
        if (json.rive_layout !== undefined) {
            const newLayout = getLayoutFit(json.rive_layout);
            if (newLayout !== state.layoutFit) {
                console.log('\nðŸ“ ========== LAYOUT CHANGE ==========');
                console.log('ðŸ“ New layout:', newLayout);
                state.layoutFit = newLayout;
                if (state.fileUrl) {
                    loadRive(state.fileUrl);
                    return;
                }
                console.log('ðŸ“ =====================================\n');
            }
        }

        // Handle artboard change
        if (json.riveartboard !== undefined && state.riveInstance) {
            console.log('\nðŸ–¼ï¸ ========== ARTBOARD CHANGE ==========');
            console.log('ðŸ–¼ï¸ Requested index:', json.riveartboard);
            console.log('ðŸ–¼ï¸ Current artboard:', state.artboardName);
            console.log('ðŸ–¼ï¸ Current stateMachine:', state.stateMachineName);
            
            const index = parseInt(json.riveartboard);
            const file = state.riveInstance.file;
            
            if (file && index >= 0 && index < file.artboardCount()) {
                const artboard = file.artboardByIndex(index);
                if (artboard) {
                    const newArtboard = getArtboardName(artboard);
                    console.log('ðŸ–¼ï¸ New artboard name:', newArtboard);
                    if (newArtboard !== state.artboardName) {
                        console.log('ðŸ–¼ï¸ Artboard CHANGED! Resetting state machine...');
                        state.artboardName = newArtboard;
                        state.stateMachineName = '';  // Reset - will auto-detect on load
                        state.availableStateMachines = [];
                        console.log('ðŸ–¼ï¸ state.stateMachineName now:', state.stateMachineName);
                        if (state.fileUrl) {
                            loadRive(state.fileUrl);
                            console.log('ðŸ–¼ï¸ ========================================\n');
                            return;
                        }
                    } else {
                        console.log('ðŸ–¼ï¸ Same artboard, skipping');
                    }
                }
            }
            console.log('ðŸ–¼ï¸ ========================================\n');
        }
        
        // Handle state machine change
        if (json.rivestatemachine !== undefined && state.riveInstance) {
            console.log('\nâš™ï¸ ========== STATE MACHINE CHANGE ==========');
            const smIndex = parseInt(json.rivestatemachine);
            console.log('âš™ï¸ Requested SM index:', smIndex);
            console.log('âš™ï¸ Available:', state.availableStateMachines);
            console.log('âš™ï¸ Current:', state.stateMachineName);
            
            if (state.availableStateMachines[smIndex]) {
                const newSM = state.availableStateMachines[smIndex];
                console.log('âš™ï¸ New state machine:', newSM);
                if (newSM !== state.stateMachineName) {
                    console.log('âš™ï¸ State machine CHANGED! Reloading with new SM...');
                    state.stateMachineName = newSM;
                    if (state.fileUrl) {
                        loadRive(state.fileUrl, newSM);
                        console.log('âš™ï¸ ==========================================\n');
                        return;
                    }
                } else {
                    console.log('âš™ï¸ Same state machine, skipping');
                }
            }
            console.log('âš™ï¸ ==========================================\n');
        }

        if (!state.riveInstance) return;

        // Handle property updates (no logging for performance)
        for (const [name, prop] of Object.entries(state.riveProps)) {
            const fieldId = toAlphanumericId(name);
            if (json[fieldId] !== undefined) {
                updateProperty(name, prop, json[fieldId]);
            }
        }
    }

    function handleButtonClick(action) {
        console.log('ðŸ”˜ [handleButtonClick] Action:', action);
        console.log('ðŸ”˜ [handleButtonClick] State machine playing:', state.stateMachineName);
        console.log('ðŸ”˜ [handleButtonClick] Rive instance:', state.riveInstance);
        console.log('ðŸ”˜ [handleButtonClick] Is playing:', state.riveInstance?.isPlaying);
        
        // Check if state machine inputs exist
        const inputs = state.riveInstance?.stateMachineInputs(state.stateMachineName);
        console.log('ðŸ”˜ [handleButtonClick] State machine inputs:', inputs);
        
        for (const [name, prop] of Object.entries(state.riveProps)) {
            const fieldId = toAlphanumericId(name);
            if (fieldId === action && prop.type === 'trigger') {
                console.log('ðŸ”˜ Found trigger:', name);
                console.log('ðŸ”˜ Property path:', prop.path);
                console.log('ðŸ”˜ Accessor type:', prop.accessor?.constructor?.name);
                
                // Check for state machine trigger input (alternative way)
                if (inputs) {
                    const smTrigger = inputs.find(i => i.name === name || i.name === prop.path);
                    console.log('ðŸ”˜ SM Trigger input:', smTrigger);
                    if (smTrigger && typeof smTrigger.fire === 'function') {
                        console.log('ðŸ”˜ Firing via SM input...');
                        smTrigger.fire();
                        return;
                    }
                }
                
                try {
                    // Try .trigger() method on view model accessor
                    if (typeof prop.accessor.trigger === 'function') {
                        console.log('ðŸ”˜ Calling .trigger() on view model accessor...');
                        const result = prop.accessor.trigger();
                        console.log('ðŸ”˜ .trigger() returned:', result);
                    }
                    // Also try .fire() as backup
                    else if (typeof prop.accessor.fire === 'function') {
                        console.log('ðŸ”˜ Calling .fire()...');
                        prop.accessor.fire();
                    }
                    else {
                        console.error('ðŸ”˜ No trigger/fire method found');
                    }
                } catch (err) {
                    console.error('ðŸ”˜ Error calling trigger:', err);
                }
                return;
            }
        }
        console.log('ðŸ”˜ Trigger not found for action:', action);
    }

    async function handleInit(json) {
        console.log('ðŸ [handleInit] Initial values:', Object.keys(json));
        state.pendingValues = json;
        
        setTimeout(async () => {
            if (state.hasInitialValues || state.initialized) return;
            try {
                const useWebGL2 = parseBool(json.rive_renderer, true);
                const desiredRuntime = useWebGL2 ? 'webgl2' : 'canvas';
                await ensureRiveRuntime(desiredRuntime);
                if (typeof json.rive_file_url === 'string' && json.rive_file_url.endsWith('.riv')) {
                    state.fileUrl = json.rive_file_url;
                    state.initialized = true;
                    loadRive(json.rive_file_url);
                }
            } catch (e) {
                console.error('ðŸ Init fallback failed:', e);
            }
        }, 500);
    }

    // -------------------- INITIALIZE --------------------
    console.log('ðŸš€ RiveLink Widget Starting...');
    window.addEventListener('resize', () => resizeCanvas(state.riveInstance));
    
    SingularWidget.init({
        onInit: handleInit,
        onValue: handleValueChange,
        onButtonClicked: handleButtonClick
    });
    console.log('ðŸš€ SingularWidget.init() called');
  </script>
</body>
</html>
